{
  "id": 18,
  "topic": "Python",
  "level": "Mid Level",
  "question": "Find connected components in an undirected graph using Python",
  "options": [
    "Use DFS from each unvisited node: O(V + E)",
    "Use BFS from each unvisited node: O(V + E)",
    "Use Union-Find: O(V + E) with optimizations",
    "All of the above work"
  ],
  "correct": 3,
  "explanation": "**Optimal Solution: DFS/BFS/Union-Find - All O(V + E)**\n\n**Problem:** Find connected components\n```\nGraph:\n1---2   4---5\n|       |\n3       6\n\nComponents: [[1,2,3], [4,5,6]]\n```\n\n**Concept: Visit all reachable nodes from each unvisited node**\n\n**Visual Process:**\n```\nStep 1: Start from node 1 (unvisited)\nVisit 1 → 2 → 3\nComponent 1: {1, 2, 3}\n\nStep 2: All nodes 1,2,3 now visited\nTry node 4 (unvisited)\nVisit 4 → 5 → 6\nComponent 2: {4, 5, 6}\n\nStep 3: All nodes visited\nResult: 2 components\n```\n\n**Python Implementation:**\n\n**Method 1: DFS (Recursive)**\n```python\ndef findComponents_DFS(n, edges):\n    # Build adjacency list\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = set()\n    components = []\n    \n    def dfs(node, component):\n        visited.add(node)\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, component)\n    \n    for node in range(n):\n        if node not in visited:\n            component = []\n            dfs(node, component)\n            components.append(component)\n    \n    return components\n```\n\n**Method 2: BFS (Iterative)**\n```python\nfrom collections import deque\n\ndef findComponents_BFS(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = set()\n    components = []\n    \n    for start in range(n):\n        if start not in visited:\n            component = []\n            queue = deque([start])\n            visited.add(start)\n            \n            while queue:\n                node = queue.popleft()\n                component.append(node)\n                \n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            \n            components.append(component)\n    \n    return components\n```\n\n**Method 3: Union-Find**\n```python\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        \n        if self.rank[px] < self.rank[py]:\n            self.parent[px] = py\n        elif self.rank[px] > self.rank[py]:\n            self.parent[py] = px\n        else:\n            self.parent[py] = px\n            self.rank[px] += 1\n        return True\n\ndef findComponents_UF(n, edges):\n    uf = UnionFind(n)\n    \n    for u, v in edges:\n        uf.union(u, v)\n    \n    from collections import defaultdict\n    components = defaultdict(list)\n    for node in range(n):\n        root = uf.find(node)\n        components[root].append(node)\n    \n    return list(components.values())\n```\n\n**Example Execution:**\n```\nGraph: 0-1, 1-2, 3-4\nn = 5, edges = [(0,1), (1,2), (3,4)]\n\nDFS from 0: visits 0 → 1 → 2\nComponent 1: [0, 1, 2]\n\nDFS from 3: visits 3 → 4\nComponent 2: [3, 4]\n\nNode 4 already visited (skip)\n\nResult: [[0,1,2], [3,4]]\n```\n\n**Comparison:**\n```\nMethod      Time        Space   Best for\nDFS         O(V+E)      O(V)    Simple, recursive\nBFS         O(V+E)      O(V)    Level-by-level\nUnion-Find  O(V+E)      O(V)    Dynamic connectivity\n```\n\n**Complexity:**\n- Time: O(V + E) where V = vertices, E = edges\n- Space: O(V) for visited set/recursion stack\n- All methods visit each node and edge once\n\n**Key Insight:** All three methods are equally efficient; choose DFS for simplicity, Union-Find for dynamic graphs.",
  "timeComplexity": "O(V + E)",
  "spaceComplexity": "O(V)",
  "videoUrl": "https://www.youtube.com/watch?v=tWVWeAqZ0WU",
  "videoTitle": "Number of Connected Components - Graph Valid Tree (NeetCode)"
}
