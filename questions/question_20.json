{
  "id": 20,
  "topic": "Python",
  "level": "Mid Level",
  "question": "Implement a rolling/sliding window maximum efficiently",
  "options": [
    "Recalculate max for each window: O(n*k)",
    "Use deque with monotonic decreasing order: O(n)",
    "Use heap: O(n log k)",
    "Use BST: O(n log k)"
  ],
  "correct": 1,
  "explanation": "**Optimal Solution: Monotonic Deque - O(n)**\n\n**Problem:** Find max in each window of size k\n```\nArray: [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\n\nWindows:\n[1  3  -1] -3  5  3  6  7  → max = 3\n 1 [3  -1  -3] 5  3  6  7  → max = 3\n 1  3 [-1  -3  5] 3  6  7  → max = 5\n 1  3  -1 [-3  5  3] 6  7  → max = 5\n 1  3  -1  -3 [5  3  6] 7  → max = 6\n 1  3  -1  -3  5 [3  6  7] → max = 7\n\nResult: [3, 3, 5, 5, 6, 7]\n```\n\n**Concept: Deque maintains potential maximums**\n```\nRules:\n1. Store indices (not values)\n2. Keep deque in decreasing order\n3. Remove expired indices (outside window)\n4. Front of deque = current maximum\n```\n\n**Visual Process:**\n```\nWindow: [1, 3, -1]\nStep 1: Add 1 → deque=[0] (index 0, val=1)\nStep 2: Add 3 → 3>1, remove 1 → deque=[1] (index 1, val=3)\nStep 3: Add -1 → -1<3, keep → deque=[1,2] (vals: 3,-1)\nMax: arr[1] = 3\n\nWindow: [3, -1, -3]\nStep 4: Remove expired (idx 0 not in deque)\nStep 5: Add -3 → -3<-1, keep → deque=[1,2,3]\nMax: arr[1] = 3\n\nWindow: [-1, -3, 5]\nStep 6: Remove expired idx 1\nStep 7: Add 5 → 5>-1 and 5>-3, remove both → deque=[4]\nMax: arr[4] = 5\n```\n\n**Deque State Visualization:**\n```\nArray:     [1, 3, -1, -3, 5, 3, 6, 7]\nWindow 1:  [1, 3, -1]\nDeque:     [1, 2]      (indices, values: 3, -1)\nMax:       3\n\nWindow 2:  [3, -1, -3]\nDeque:     [1, 2, 3]   (values: 3, -1, -3)\nMax:       3\n\nWindow 3:  [-1, -3, 5]\nDeque:     [4]         (value: 5)\nMax:       5\n```\n\n**Python Implementation:**\n```python\nfrom collections import deque\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k == 0:\n        return []\n    \n    dq = deque()  # Store indices\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices outside current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove indices with smaller values\n        # (they can never be maximum)\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        # Add current index\n        dq.append(i)\n        \n        # Add to result once we have k elements\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n```\n\n**Why Each Element Enters/Exits Once:**\n```\nEach index i:\n- Added to deque once: O(1)\n- Removed at most once: O(1)\n- Total operations per element: O(1)\n- Total for n elements: O(n)\n```\n\n**Example Trace:**\n```python\nnums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3\n\ni=0: dq=[0], window not full\ni=1: dq=[1] (removed 0), window not full\ni=2: dq=[1,2], result=[3]\ni=3: dq=[1,2,3], result=[3,3]\ni=4: dq=[4] (removed 1,2,3), result=[3,3,5]\ni=5: dq=[4,5], result=[3,3,5,5]\ni=6: dq=[6] (removed 4,5), result=[3,3,5,5,6]\ni=7: dq=[7] (removed 6), result=[3,3,5,5,6,7]\n```\n\n**Comparison:**\n```\nMethod              Time        Space   Notes\nBrute Force         O(n*k)      O(1)    Recalc each window\nHeap                O(n log k)  O(k)    Need to remove old\nMonotonic Deque     O(n)        O(k)    Optimal!\nBST/TreeMap         O(n log k)  O(k)    Overkill\n```\n\n**Complexity:**\n- Time: O(n) - each element added/removed at most once\n- Space: O(k) - deque holds at most k indices\n\n**Key Insight:** Monotonic deque eliminates elements that can never be maximum, achieving O(n) time.",
  "timeComplexity": "O(n)",
  "spaceComplexity": "O(k)",
  "videoUrl": "https://www.youtube.com/watch?v=DfljaUwZsOk",
  "videoTitle": "Sliding Window Maximum - Leetcode 239 - Python (NeetCode)"
}
