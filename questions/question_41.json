{
  "id": 41,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Design a real-time leaderboard system with ranking",
  "options": [
    "Sort on every query: O(n log n)",
    "Use sorted list with binary search: O(log n) query",
    "Use skip list or balanced tree: O(log n)",
    "Both B and C are efficient"
  ],
  "correct": 3,
  "explanation": "**Optimal Solution: Sorted Data Structure - O(log n)**\n\n**Problem:** Maintain rankings with updates and queries\n\n**Operations Needed:**\n```\n1. Add player with score\n2. Update player score\n3. Get player rank\n4. Get top K players\n5. Get players around rank\n```\n\n**Visual Leaderboard:**\n```\nRank  Player  Score\n  1   Alice   1000\n  2   Bob     950\n  3   Carol   900\n  4   Dave    850\n  5   Eve     800\n\nAlice updates score to 875:\n  1   Bob     950\n  2   Carol   900\n  3   Alice   875  ← moved down\n  4   Dave    850\n  5   Eve     800\n```\n\n**Data Structure Options:**\n```\n1. List + sort: O(n log n) per update\n2. Heap: O(log n) insert, O(n) rank query\n3. Balanced BST: O(log n) all ops ✓\n4. Skip list: O(log n) all ops ✓\n5. Sorted list: O(n) insert, O(log n) search\n```\n\n**Python Implementation:**\n```python\nfrom sortedcontainers import SortedList\nimport bisect\n\n# Method 1: Using SortedList (best for Python)\nclass Leaderboard1:\n    def __init__(self):\n        # player_id -> score\n        self.scores = {}\n        # Sorted list of (-score, player_id)\n        # Negative score for descending order\n        self.sorted_scores = SortedList()\n    \n    def add_score(self, player_id, score):\n        \"\"\"Add or update player score\"\"\"\n        # Remove old score if exists\n        if player_id in self.scores:\n            old_score = self.scores[player_id]\n            self.sorted_scores.remove((-old_score, player_id))\n        \n        # Add new score\n        self.scores[player_id] = score\n        self.sorted_scores.add((-score, player_id))\n    \n    def get_rank(self, player_id):\n        \"\"\"Get player's rank (1-indexed)\"\"\"\n        if player_id not in self.scores:\n            return None\n        \n        score = self.scores[player_id]\n        # Find position in sorted list\n        idx = self.sorted_scores.index((-score, player_id))\n        return idx + 1\n    \n    def get_top(self, k):\n        \"\"\"Get top K players\"\"\"\n        result = []\n        for i in range(min(k, len(self.sorted_scores))):\n            score, player_id = self.sorted_scores[i]\n            result.append((player_id, -score))\n        return result\n    \n    def get_score(self, player_id):\n        \"\"\"Get player's score\"\"\"\n        return self.scores.get(player_id)\n\n# Method 2: Manual binary search (no dependencies)\nclass Leaderboard2:\n    def __init__(self):\n        self.scores = {}\n        # List of (score, player_id) sorted by score desc\n        self.leaderboard = []\n    \n    def add_score(self, player_id, score):\n        # Remove old entry\n        if player_id in self.scores:\n            old_score = self.scores[player_id]\n            # Binary search and remove\n            idx = self._find_index(old_score, player_id)\n            if idx != -1:\n                self.leaderboard.pop(idx)\n        \n        # Insert new entry\n        self.scores[player_id] = score\n        # Find insertion point (negative for desc order)\n        idx = bisect.bisect_left(\n            [(-s, p) for s, p in self.leaderboard],\n            (-score, player_id)\n        )\n        self.leaderboard.insert(idx, (score, player_id))\n    \n    def _find_index(self, score, player_id):\n        \"\"\"Find index of player in leaderboard\"\"\"\n        for i, (s, p) in enumerate(self.leaderboard):\n            if s == score and p == player_id:\n                return i\n        return -1\n    \n    def get_rank(self, player_id):\n        if player_id not in self.scores:\n            return None\n        \n        score = self.scores[player_id]\n        idx = self._find_index(score, player_id)\n        return idx + 1 if idx != -1 else None\n    \n    def get_top(self, k):\n        return [(p, s) for s, p in self.leaderboard[:k]]\n\n# Method 3: Using heap (less efficient for rank queries)\nimport heapq\n\nclass Leaderboard3:\n    def __init__(self):\n        self.scores = {}\n    \n    def add_score(self, player_id, score):\n        self.scores[player_id] = score\n    \n    def get_top(self, k):\n        # Create max heap (negate scores)\n        heap = [(-score, player_id) \n                for player_id, score in self.scores.items()]\n        heapq.heapify(heap)\n        \n        result = []\n        for _ in range(min(k, len(heap))):\n            score, player_id = heapq.heappop(heap)\n            result.append((player_id, -score))\n        \n        return result\n    \n    def get_rank(self, player_id):\n        # O(n log n) - not efficient!\n        if player_id not in self.scores:\n            return None\n        \n        sorted_scores = sorted(self.scores.items(), \n                             key=lambda x: -x[1])\n        \n        for rank, (pid, score) in enumerate(sorted_scores, 1):\n            if pid == player_id:\n                return rank\n        return None\n```\n\n**Usage Example:**\n```python\nlb = Leaderboard1()\n\n# Add players\nlb.add_score(\"alice\", 1000)\nlb.add_score(\"bob\", 950)\nlb.add_score(\"carol\", 900)\nlb.add_score(\"dave\", 850)\n\nprint(lb.get_rank(\"alice\"))  # 1\nprint(lb.get_rank(\"dave\"))   # 4\n\n# Get top 3\nprint(lb.get_top(3))\n# [('alice', 1000), ('bob', 950), ('carol', 900)]\n\n# Update alice's score\nlb.add_score(\"alice\", 875)\nprint(lb.get_rank(\"alice\"))  # 3 (moved down)\n\n# Top 3 now\nprint(lb.get_top(3))\n# [('bob', 950), ('carol', 900), ('alice', 875)]\n```\n\n**Advanced Features:**\n```python\nclass AdvancedLeaderboard:\n    def __init__(self):\n        self.scores = {}\n        self.sorted_scores = SortedList()\n    \n    def add_score(self, player_id, score):\n        if player_id in self.scores:\n            old_score = self.scores[player_id]\n            self.sorted_scores.remove((-old_score, player_id))\n        \n        self.scores[player_id] = score\n        self.sorted_scores.add((-score, player_id))\n    \n    def get_rank(self, player_id):\n        if player_id not in self.scores:\n            return None\n        score = self.scores[player_id]\n        idx = self.sorted_scores.index((-score, player_id))\n        return idx + 1\n    \n    def get_players_around(self, player_id, count=5):\n        \"\"\"Get players around given player\"\"\"\n        rank = self.get_rank(player_id)\n        if rank is None:\n            return []\n        \n        start = max(0, rank - count - 1)\n        end = min(len(self.sorted_scores), rank + count)\n        \n        result = []\n        for i in range(start, end):\n            score, pid = self.sorted_scores[i]\n            result.append((i + 1, pid, -score))\n        \n        return result\n    \n    def get_percentile(self, player_id):\n        \"\"\"Get player's percentile\"\"\"\n        rank = self.get_rank(player_id)\n        if rank is None:\n            return None\n        \n        total = len(self.sorted_scores)\n        percentile = ((total - rank) / total) * 100\n        return round(percentile, 2)\n```\n\n**Complexity Comparison:**\n```\nOperation        List+Sort  Heap     SortedList  BST\nAdd/Update       O(n log n) O(log n) O(log n)    O(log n)\nGet Rank         O(n)       O(n)     O(log n)    O(log n)\nGet Top K        O(n log n) O(k log n) O(k)      O(k)\nGet Score        O(1)       O(1)     O(1)        O(log n)\n```\n\n**Redis Implementation (Distributed):**\n```python\nimport redis\n\nclass RedisLeaderboard:\n    def __init__(self, redis_client, leaderboard_name):\n        self.redis = redis_client\n        self.key = f\"leaderboard:{leaderboard_name}\"\n    \n    def add_score(self, player_id, score):\n        \"\"\"Add player with score to sorted set\"\"\"\n        self.redis.zadd(self.key, {player_id: score})\n    \n    def get_rank(self, player_id):\n        \"\"\"Get player rank (0-indexed, reverse for desc)\"\"\"\n        rank = self.redis.zrevrank(self.key, player_id)\n        return rank + 1 if rank is not None else None\n    \n    def get_top(self, k):\n        \"\"\"Get top k players with scores\"\"\"\n        return self.redis.zrevrange(self.key, 0, k-1, \n                                   withscores=True)\n    \n    def get_score(self, player_id):\n        return self.redis.zscore(self.key, player_id)\n```\n\n**Key Insight:** Sorted container maintains order on updates; enables O(log n) operations for both updates and rank queries; essential for real-time leaderboards.",
  "timeComplexity": "O(log n) per operation",
  "spaceComplexity": "O(n)",
  "videoUrl": "https://www.youtube.com/watch?v=mrCsjDoRsQw",
  "videoTitle": "Design a Leaderboard - System Design"
}
