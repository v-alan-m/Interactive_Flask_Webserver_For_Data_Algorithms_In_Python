{
  "id": 31,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Design a real-time leaderboard with rank updates in O(log n)",
  "options": [
    "Use sorted list: O(n) for insert",
    "Use heap: O(log n) insert but O(n) for rank",
    "Use balanced BST (SortedList): O(log n) all ops",
    "Use hash map only: O(1) insert but O(n) for rank"
  ],
  "correct": 2,
  "explanation": "**Optimal Solution: Balanced BST (SortedList) - O(log n)**\n\n**Problem:** Real-time leaderboard with operations:\n```\n- addScore(player, score): update player's score\n- getRank(player): get player's rank\n- getTopK(k): get top k players\n```\n\n**Requirements:**\n```\n- Fast score updates: O(log n)\n- Fast rank queries: O(log n)\n- Handle ties (same scores)\n- Millions of players\n```\n\n**Visual Example:**\n```\nLeaderboard:\nRank  Player  Score\n1     Alice   1000\n2     Bob     950\n3     Charlie 900\n4     David   850\n\naddScore(Bob, 1100):\nRank  Player  Score\n1     Bob     1100  â† moved up\n2     Alice   1000\n3     Charlie 900\n4     David   850\n```\n\n**Why SortedList?**\n```\nSortedList (from sortedcontainers):\n- Maintains sorted order automatically\n- Binary search for position: O(log n)\n- Insert/delete: O(log n)\n- Access by index: O(1)\n\nPerfect for leaderboard!\n```\n\n**Python Implementation:**\n```python\nfrom sortedcontainers import SortedList\n\nclass Leaderboard:\n    def __init__(self):\n        # SortedList of (score, player) tuples\n        # Sorted by score descending, then player name\n        self.scores = SortedList(key=lambda x: (-x[0], x[1]))\n        self.player_to_score = {}  # player -> score\n    \n    def addScore(self, player, score):\n        # Remove old score if exists\n        if player in self.player_to_score:\n            old_score = self.player_to_score[player]\n            self.scores.remove((old_score, player))\n        \n        # Add new score\n        self.scores.add((score, player))\n        self.player_to_score[player] = score\n    \n    def getRank(self, player):\n        if player not in self.player_to_score:\n            return -1\n        \n        score = self.player_to_score[player]\n        # Binary search for position\n        index = self.scores.index((score, player))\n        return index + 1  # Ranks are 1-indexed\n    \n    def getTopK(self, k):\n        return [(player, score) for score, player in self.scores[:k]]\n    \n    def getScoreDiff(self, player1, player2):\n        if player1 not in self.player_to_score or player2 not in self.player_to_score:\n            return None\n        return self.player_to_score[player1] - self.player_to_score[player2]\n\n# Alternative: Using heapq (less efficient for rank queries)\nimport heapq\n\nclass LeaderboardHeap:\n    def __init__(self):\n        self.heap = []  # max heap (negate scores)\n        self.player_to_score = {}\n    \n    def addScore(self, player, score):\n        self.player_to_score[player] = score\n        # Rebuild heap (inefficient)\n        self.heap = [(-s, p) for p, s in self.player_to_score.items()]\n        heapq.heapify(self.heap)\n    \n    def getTopK(self, k):\n        return [(-s, p) for s, p in heapq.nsmallest(k, self.heap)]\n    \n    def getRank(self, player):\n        # O(n) - need to iterate all\n        if player not in self.player_to_score:\n            return -1\n        score = self.player_to_score[player]\n        rank = 1\n        for s, p in sorted(self.heap):\n            if p == player:\n                return rank\n            rank += 1\n        return -1\n```\n\n**Example Usage:**\n```python\nleaderboard = Leaderboard()\n\n# Add scores\nleaderboard.addScore(\"Alice\", 1000)\nleaderboard.addScore(\"Bob\", 950)\nleaderboard.addScore(\"Charlie\", 900)\nleaderboard.addScore(\"David\", 850)\n\n# Get rankings\nprint(leaderboard.getRank(\"Alice\"))    # 1\nprint(leaderboard.getRank(\"Bob\"))      # 2\nprint(leaderboard.getRank(\"Charlie\"))  # 3\n\n# Update Bob's score\nleaderboard.addScore(\"Bob\", 1100)\nprint(leaderboard.getRank(\"Bob\"))      # 1 (now top)\nprint(leaderboard.getRank(\"Alice\"))    # 2 (moved down)\n\n# Get top 3\nprint(leaderboard.getTopK(3))\n# [('Bob', 1100), ('Alice', 1000), ('Charlie', 900)]\n```\n\n**Handling Ties:**\n```python\nclass LeaderboardWithTies:\n    def __init__(self):\n        # Sort by score desc, then player name asc for deterministic ties\n        self.scores = SortedList(key=lambda x: (-x[0], x[1]))\n        self.player_to_score = {}\n    \n    def getRank(self, player):\n        if player not in self.player_to_score:\n            return -1\n        \n        score = self.player_to_score[player]\n        \n        # Count players with higher scores\n        rank = 1\n        for s, p in self.scores:\n            if s > score:\n                rank += 1\n            elif s == score and p == player:\n                return rank\n        return rank\n\n# Example with ties:\nleaderboard.addScore(\"Alice\", 1000)\nleaderboard.addScore(\"Bob\", 1000)  # Same score\nleaderboard.addScore(\"Charlie\", 900)\n\n# Both Alice and Bob could be rank 1 or 2\n# depending on tie-breaking rules\n```\n\n**Performance Comparison:**\n```\nData Structure      addScore  getRank  getTopK  Space\nSortedList          O(log n)  O(log n) O(k)     O(n)\nHeap                O(log n)  O(n)     O(k log n) O(n)\nSorted Array        O(n)      O(log n) O(k)     O(n)\nHash Map only       O(1)      O(n log n) O(n log n) O(n)\nBalanced BST        O(log n)  O(log n) O(k)     O(n)\n```\n\n**Real-World Optimizations:**\n```python\nclass ScalableLeaderboard:\n    def __init__(self):\n        self.scores = SortedList(key=lambda x: (-x[0], x[1]))\n        self.player_to_score = {}\n        self.rank_cache = {}  # Cache frequently queried ranks\n    \n    def addScore(self, player, score):\n        # Invalidate cache when scores change\n        self.rank_cache.clear()\n        \n        if player in self.player_to_score:\n            old_score = self.player_to_score[player]\n            self.scores.remove((old_score, player))\n        \n        self.scores.add((score, player))\n        self.player_to_score[player] = score\n    \n    def getRank(self, player):\n        # Check cache first\n        if player in self.rank_cache:\n            return self.rank_cache[player]\n        \n        if player not in self.player_to_score:\n            return -1\n        \n        score = self.player_to_score[player]\n        index = self.scores.index((score, player))\n        rank = index + 1\n        \n        # Cache the result\n        self.rank_cache[player] = rank\n        return rank\n```\n\n**Distributed Leaderboard (Redis):**\n```python\nimport redis\n\nclass RedisLeaderboard:\n    def __init__(self):\n        self.redis = redis.Redis()\n        self.key = \"game:leaderboard\"\n    \n    def addScore(self, player, score):\n        # Redis Sorted Set: O(log n)\n        self.redis.zadd(self.key, {player: score})\n    \n    def getRank(self, player):\n        # Get rank (0-indexed, reverse for descending)\n        rank = self.redis.zrevrank(self.key, player)\n        return rank + 1 if rank is not None else -1\n    \n    def getTopK(self, k):\n        # Get top k with scores\n        return self.redis.zrevrange(self.key, 0, k-1, withscores=True)\n```\n\n**Complexity:**\n- addScore: O(log n) - balanced tree insert\n- getRank: O(log n) - binary search\n- getTopK: O(k) - slice from sorted structure\n- Space: O(n) - store all players\n\n**Key Insight:** SortedList (balanced BST) provides O(log n) for all operations, making it ideal for real-time leaderboards with millions of players.",
  "timeComplexity": "O(log n)",
  "spaceComplexity": "O(n)",
  "videoUrl": "https://www.youtube.com/watch?v=U4ogK0MIzqk",
  "videoTitle": "Design Leaderboard - System Design (Gaurav Sen)"
}
