{
  "id": 40,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Generate all k-combinations from n elements efficiently",
  "options": [
    "Nested loops: not scalable",
    "Recursion with backtracking: O(C(n,k))",
    "Itertools.combinations: O(C(n,k))",
    "Both B and C are optimal"
  ],
  "correct": 3,
  "explanation": "**Optimal Solution: Backtracking or itertools - O(C(n,k))**\n\n**Problem:** Generate all ways to choose k items from n items\n\n**Example:** n=[1,2,3,4], k=2\n```\nResult:\n[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]\n\nC(4,2) = 4!/(2!*2!) = 6 combinations\n```\n\n**Visual Backtracking Tree:**\n```\nGenerate combinations(4, 2):\n\n                  []\n           /      |      \\      \\\n        [1]     [2]    [3]    [4]\n       / | \\     |  \\     |\n    [1,2][1,3][1,4] [2,3][2,4] [3,4]\n     ✓    ✓    ✓     ✓    ✓     ✓\n\nPrune: Don't go backwards!\n[1] → can pick 2,3,4\n[2] → can pick 3,4 (not 1!)\n[3] → can pick 4\n```\n\n**Step-by-Step Process:**\n```\nInput: [1,2,3,4], k=2\n\nStart: [], need 2 more\n├─ Add 1: [1], need 1 more\n│  ├─ Add 2: [1,2] ✓ Complete!\n│  ├─ Add 3: [1,3] ✓ Complete!\n│  └─ Add 4: [1,4] ✓ Complete!\n├─ Add 2: [2], need 1 more\n│  ├─ Add 3: [2,3] ✓ Complete!\n│  └─ Add 4: [2,4] ✓ Complete!\n├─ Add 3: [3], need 1 more\n│  └─ Add 4: [3,4] ✓ Complete!\n└─ Add 4: [4], need 1 more\n   └─ No more elements!\n```\n\n**Python Implementation:**\n```python\n# Method 1: Recursive backtracking (educational)\ndef combine1(n, k):\n    result = []\n    \n    def backtrack(start, current):\n        # Base case: combination complete\n        if len(current) == k:\n            result.append(current[:])\n            return\n        \n        # Try each number from start to n\n        for i in range(start, n + 1):\n            current.append(i)\n            backtrack(i + 1, current)\n            current.pop()  # backtrack\n    \n    backtrack(1, [])\n    return result\n\n# Method 2: With array input\ndef combine2(nums, k):\n    result = []\n    \n    def backtrack(start, current):\n        if len(current) == k:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(0, [])\n    return result\n\n# Method 3: Using itertools (most Pythonic)\nfrom itertools import combinations\n\ndef combine3(nums, k):\n    return list(combinations(nums, k))\n\n# Method 4: Iterative using bit manipulation\ndef combine4(n, k):\n    result = []\n    \n    # Generate all subsets of size k\n    def next_combination(comb, n, k):\n        # Find rightmost element that can be incremented\n        i = k - 1\n        while i >= 0 and comb[i] == n - k + i + 1:\n            i -= 1\n        \n        if i < 0:\n            return None\n        \n        comb[i] += 1\n        for j in range(i + 1, k):\n            comb[j] = comb[j - 1] + 1\n        \n        return comb[:]\n    \n    comb = list(range(1, k + 1))\n    result.append(comb[:])\n    \n    while True:\n        comb = next_combination(comb, n, k)\n        if comb is None:\n            break\n        result.append(comb)\n    \n    return result\n\n# Method 5: Generator (memory efficient)\ndef combine_generator(nums, k):\n    def backtrack(start, current):\n        if len(current) == k:\n            yield current[:]\n            return\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            yield from backtrack(i + 1, current)\n            current.pop()\n    \n    yield from backtrack(0, [])\n\n# Usage\nfor combo in combine_generator([1,2,3,4], 2):\n    print(combo)\n```\n\n**Example Traces:**\n```python\n# Example 1\ncombine1(4, 2)\n# [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]\n\n# Example 2\ncombine2(['a','b','c'], 2)\n# [['a','b'], ['a','c'], ['b','c']]\n\n# Example 3\ncombine3([1,2,3,4,5], 3)\n# [[1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], \n#  [1,4,5], [2,3,4], [2,3,5], [2,4,5], [3,4,5]]\n```\n\n**Optimization: Early Pruning**\n```python\ndef combine_optimized(n, k):\n    result = []\n    \n    def backtrack(start, current):\n        # Pruning: not enough elements left\n        if len(current) + (n - start + 1) < k:\n            return\n        \n        if len(current) == k:\n            result.append(current[:])\n            return\n        \n        for i in range(start, n + 1):\n            current.append(i)\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(1, [])\n    return result\n\n# Example: combine(10, 5)\n# Without pruning: tries many impossible paths\n# With pruning: skips when remaining < needed\n```\n\n**Mathematical Properties:**\n```\nC(n, k) = n! / (k! * (n-k)!)\n\nC(4, 2) = 4! / (2! * 2!) = 24 / 4 = 6\nC(5, 3) = 5! / (3! * 2!) = 120 / 12 = 10\n\nSymmetry: C(n, k) = C(n, n-k)\nC(4, 2) = C(4, 2) = 6\n\nPascal's Triangle:\nC(n, k) = C(n-1, k-1) + C(n-1, k)\n```\n\n**Comparison:**\n```\nMethod          Time         Space      Use case\nBacktracking    O(C(n,k)*k)  O(k)       Educational\nItertools       O(C(n,k)*k)  O(k)       Production\nBit manip       O(C(n,k)*k)  O(k)       Interview\nGenerator       O(C(n,k)*k)  O(k)       Large n,k\n```\n\n**Related Problems:**\n```python\n# Permutations (order matters)\nfrom itertools import permutations\nlist(permutations([1,2,3], 2))\n# [(1,2), (1,3), (2,1), (2,3), (3,1), (3,2)]\n\n# Combinations with replacement\nfrom itertools import combinations_with_replacement\nlist(combinations_with_replacement([1,2], 2))\n# [(1,1), (1,2), (2,2)]\n\n# Power set (all subsets)\ndef power_set(nums):\n    result = []\n    for k in range(len(nums) + 1):\n        result.extend(combinations(nums, k))\n    return result\n```\n\n**Edge Cases:**\n```python\n# k = 0\ncombine(3, 0)  # [[]]\n\n# k = n\ncombine(3, 3)  # [[1,2,3]]\n\n# k > n\ncombine(2, 3)  # []\n\n# n = 0\ncombine(0, 0)  # [[]]\n```\n\n**Complexity:**\n- Time: O(C(n,k) * k) to generate and copy\n- Space: O(k) for recursion stack\n- Output size: O(C(n,k) * k)\n- C(n,k) grows exponentially!\n\n**Key Insight:** Backtracking naturally avoids duplicates by only considering forward choices; itertools.combinations is optimized C implementation.",
  "timeComplexity": "O(C(n,k) * k)",
  "spaceComplexity": "O(k)",
  "videoUrl": "https://www.youtube.com/watch?v=qGyyzpP-9eE",
  "videoTitle": "Combinations - Backtracking - Leetcode 77 - Python (NeetCode)"
}
