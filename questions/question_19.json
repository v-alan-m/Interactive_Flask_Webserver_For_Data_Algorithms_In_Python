{
  "id": 19,
  "topic": "Python",
  "level": "Mid Level",
  "question": "Design a URL shortener with collision handling in Python",
  "options": [
    "Use random strings: possible collisions",
    "Use hash with collision detection: O(1) average",
    "Use counter: predictable URLs",
    "Both A and B work, B is better"
  ],
  "correct": 3,
  "explanation": "**Optimal Solution: Hash with Collision Detection - O(1)**\n\n**Problem:** Map long URLs to short codes\n```\nLong:  https://example.com/very/long/url/path\nShort: abc123\n\nBijection (one-to-one mapping)\n```\n\n**Design Components:**\n```\n1. Encode: long_url → short_code\n2. Decode: short_code → long_url\n3. Handle collisions\n4. Base62 encoding (a-z, A-Z, 0-9)\n```\n\n**Visual Flow:**\n```\nEncode:\n\"https://example.com/page\" \n    ↓ hash\n\"abc123\"\n    ↓ store\n{short → long, long → short}\n\nDecode:\n\"abc123\"\n    ↓ lookup\n\"https://example.com/page\"\n```\n\n**Python Implementation:**\n```python\nimport hashlib\nimport random\nimport string\n\nclass URLShortener:\n    def __init__(self):\n        self.url_to_code = {}\n        self.code_to_url = {}\n        self.base_url = \"http://short.url/\"\n        self.chars = string.ascii_letters + string.digits\n    \n    def _generate_code(self, url, length=6):\n        \"\"\"Generate short code using hash\"\"\"\n        hash_val = hashlib.md5(url.encode()).hexdigest()\n        code = hash_val[:length]\n        return code\n    \n    def _random_code(self, length=6):\n        \"\"\"Generate random code for collision\"\"\"\n        return ''.join(random.choices(self.chars, k=length))\n    \n    def encode(self, long_url):\n        # Check if already encoded\n        if long_url in self.url_to_code:\n            return self.base_url + self.url_to_code[long_url]\n        \n        # Generate code\n        code = self._generate_code(long_url)\n        \n        # Handle collision\n        while code in self.code_to_url:\n            code = self._random_code()\n        \n        # Store mapping\n        self.url_to_code[long_url] = code\n        self.code_to_url[code] = long_url\n        \n        return self.base_url + code\n    \n    def decode(self, short_url):\n        code = short_url.replace(self.base_url, \"\")\n        return self.code_to_url.get(code, None)\n\n# Method 2: Counter-based (simpler)\nclass URLShortenerCounter:\n    def __init__(self):\n        self.url_to_code = {}\n        self.code_to_url = {}\n        self.counter = 0\n        self.chars = string.ascii_letters + string.digits\n    \n    def _base62_encode(self, num):\n        \"\"\"Convert number to base62 string\"\"\"\n        if num == 0:\n            return self.chars[0]\n        \n        result = []\n        base = len(self.chars)\n        while num:\n            result.append(self.chars[num % base])\n            num //= base\n        return ''.join(reversed(result))\n    \n    def encode(self, long_url):\n        if long_url in self.url_to_code:\n            return self.url_to_code[long_url]\n        \n        code = self._base62_encode(self.counter)\n        self.counter += 1\n        \n        self.url_to_code[long_url] = code\n        self.code_to_url[code] = long_url\n        \n        return code\n    \n    def decode(self, code):\n        return self.code_to_url.get(code, None)\n```\n\n**Example Usage:**\n```python\nshortener = URLShortener()\n\n# Encode URLs\nshort1 = shortener.encode(\"https://example.com/page1\")\n# \"http://short.url/a1b2c3\"\n\nshort2 = shortener.encode(\"https://example.com/page2\")\n# \"http://short.url/d4e5f6\"\n\n# Decode\nlong1 = shortener.decode(short1)\n# \"https://example.com/page1\"\n\n# Same URL returns same code\nshort1_again = shortener.encode(\"https://example.com/page1\")\n# \"http://short.url/a1b2c3\" (same as short1)\n```\n\n**Collision Handling:**\n```\nURL 1: \"https://a.com\" → hash → \"abc123\"\nURL 2: \"https://b.com\" → hash → \"abc123\" (collision!)\n    ↓ regenerate random\nURL 2: \"https://b.com\" → random → \"xyz789\"\n```\n\n**Design Considerations:**\n```\nApproach        Pros                    Cons\nHash-based      Deterministic           Collisions possible\nCounter-based   No collisions           Predictable, sequential\nRandom          Unpredictable           Must check duplicates\nHybrid          Best of both            More complex\n```\n\n**Complexity:**\n- Encode: O(1) average (with collision handling)\n- Decode: O(1) hash table lookup\n- Space: O(n) where n = number of URLs\n\n**Key Insight:** Use hash for speed, handle rare collisions with random generation; counter-based is simpler but predictable.",
  "timeComplexity": "O(1) average",
  "spaceComplexity": "O(n)",
  "videoUrl": "https://www.youtube.com/watch?v=fMZMm_0ZhK4",
  "videoTitle": "System Design: URL Shortener (Gaurav Sen)"
}
