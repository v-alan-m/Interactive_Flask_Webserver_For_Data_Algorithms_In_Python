{
  "id": 34,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Find longest substring with at most K distinct characters",
  "options": [
    "Brute force all substrings: O(n³)",
    "Two pointers with hash map: O(n)",
    "Dynamic programming: O(n²)",
    "Binary search: O(n log n)"
  ],
  "correct": 1,
  "explanation": "**Optimal Solution: Sliding Window + Hash Map - O(n)**\n\n**Problem:** Find longest substring with ≤ K distinct chars\n\n**Example:** s = \"eceba\", k = 2\n\n**Visual Process:**\n```\nWindow expands:\n[e]           distinct=1, valid, len=1\n[ec]          distinct=2, valid, len=2\n[ece]         distinct=2, valid, len=3 ← max\n[eceb]        distinct=3, invalid!\n\nWindow contracts:\n [ceb]        distinct=3, invalid\n  [eb]        distinct=2, valid, len=2\n  [eba]       distinct=3, invalid\n   [ba]       distinct=2, valid, len=2\n\nResult: \"ece\" (length 3)\n```\n\n**Step-by-Step:**\n```\ns = \"eceba\", k = 2\n\nleft=0, right=0: {e:1} → len=1, max=1\nleft=0, right=1: {e:1,c:1} → len=2, max=2\nleft=0, right=2: {e:2,c:1} → len=3, max=3\nleft=0, right=3: {e:2,c:1,b:1} → 3 distinct > k!\n  Contract: left=1, {c:1,e:1,b:1} → still 3\n  Contract: left=2, {e:1,b:1} → len=2\nleft=2, right=4: {e:1,b:1,a:1} → 3 distinct > k!\n  Contract: left=3, {b:1,a:1} → len=2\n\nMax length: 3\n```\n\n**Python Implementation:**\n```python\nfrom collections import defaultdict\n\ndef lengthOfLongestSubstringKDistinct(s, k):\n    if k == 0:\n        return 0\n    \n    left = 0\n    max_len = 0\n    char_count = defaultdict(int)\n    \n    for right in range(len(s)):\n        # Expand window\n        char_count[s[right]] += 1\n        \n        # Contract window if too many distinct chars\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        # Update max length\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Alternative: More readable\ndef lengthOfLongestSubstring(s, k):\n    char_freq = {}\n    left = 0\n    result = 0\n    \n    for right, char in enumerate(s):\n        char_freq[char] = char_freq.get(char, 0) + 1\n        \n        # Shrink window until valid\n        while len(char_freq) > k:\n            left_char = s[left]\n            char_freq[left_char] -= 1\n            if char_freq[left_char] == 0:\n                del char_freq[left_char]\n            left += 1\n        \n        result = max(result, right - left + 1)\n    \n    return result\n\n# Get the actual substring\ndef getLongestSubstring(s, k):\n    char_freq = {}\n    left = 0\n    max_len = 0\n    start_idx = 0\n    \n    for right in range(len(s)):\n        char_freq[s[right]] = char_freq.get(s[right], 0) + 1\n        \n        while len(char_freq) > k:\n            char_freq[s[left]] -= 1\n            if char_freq[s[left]] == 0:\n                del char_freq[s[left]]\n            left += 1\n        \n        if right - left + 1 > max_len:\n            max_len = right - left + 1\n            start_idx = left\n    \n    return s[start_idx:start_idx + max_len]\n```\n\n**Examples:**\n```python\nlengthOfLongestSubstringKDistinct(\"eceba\", 2)  # 3 (\"ece\")\nlengthOfLongestSubstringKDistinct(\"aa\", 1)     # 2 (\"aa\")\nlengthOfLongestSubstringKDistinct(\"a\", 2)      # 1 (\"a\")\nlengthOfLongestSubstringKDistinct(\"abaccc\", 2) # 4 (\"accc\")\n```\n\n**Why Sliding Window Works:**\n```\n1. Expand right: add new character\n2. If distinct > k: contract left\n3. Track maximum valid window\n4. Each char added/removed once → O(n)\n```\n\n**Edge Cases:**\n```python\n# k = 0\nlengthOfLongestSubstring(\"\", 0)      # 0\n\n# k >= all distinct chars\nlengthOfLongestSubstring(\"abc\", 5)   # 3 (entire string)\n\n# All same character\nlengthOfLongestSubstring(\"aaaa\", 1)  # 4\n\n# Empty string\nlengthOfLongestSubstring(\"\", 2)      # 0\n```\n\n**Complexity:**\n- Time: O(n) - each character visited at most twice\n- Space: O(k) - hash map stores at most k+1 distinct chars\n\n**Key Insight:** Sliding window with two pointers maintains valid window efficiently; expand right, contract left when invalid.",
  "timeComplexity": "O(n)",
  "spaceComplexity": "O(k)",
  "videoUrl": "https://www.youtube.com/watch?v=MK-NZ4hN7rs",
  "videoTitle": "Longest Substring with At Most K Distinct Characters (Leetcode Premium)"
}
