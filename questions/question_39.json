{
  "id": 39,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Implement a moving average from a data stream with window size",
  "options": [
    "Store all values, recalculate: O(k) per call",
    "Use deque, maintain sum: O(1) per call",
    "Use circular buffer: O(1) per call",
    "Both B and C are O(1)"
  ],
  "correct": 3,
  "explanation": "**Optimal Solution: Deque or Circular Buffer - O(1)**\n\n**Problem:** Calculate average of last K elements efficiently\n\n**Naive Approach:**\n```\nStore all K values\nOn new value: recalculate sum and divide\nTime: O(k) per call\n```\n\n**Optimized Approach:**\n```\nMaintain running sum\nOn new value:\n  1. Add new value to sum\n  2. Remove oldest value from sum\n  3. Return sum / count\nTime: O(1) per call\n```\n\n**Visual Process:**\n```\nWindow size: 3\nStream: [1, 10, 3, 5]\n\nStep 1: Add 1\nWindow: [1]\nSum: 1, Count: 1, Avg: 1.0\n\nStep 2: Add 10\nWindow: [1, 10]\nSum: 11, Count: 2, Avg: 5.5\n\nStep 3: Add 3\nWindow: [1, 10, 3]\nSum: 14, Count: 3, Avg: 4.67\n\nStep 4: Add 5 (remove 1)\nWindow: [10, 3, 5]\nSum: 14-1+5=18, Count: 3, Avg: 6.0\n```\n\n**Python Implementation:**\n```python\nfrom collections import deque\n\n# Method 1: Using deque (most Pythonic)\nclass MovingAverage1:\n    def __init__(self, size):\n        self.size = size\n        self.queue = deque()\n        self.window_sum = 0\n    \n    def next(self, val):\n        self.queue.append(val)\n        self.window_sum += val\n        \n        # Remove oldest if window full\n        if len(self.queue) > self.size:\n            removed = self.queue.popleft()\n            self.window_sum -= removed\n        \n        return self.window_sum / len(self.queue)\n\n# Method 2: Using circular buffer (more space efficient)\nclass MovingAverage2:\n    def __init__(self, size):\n        self.size = size\n        self.buffer = [0] * size\n        self.count = 0\n        self.index = 0\n        self.window_sum = 0\n    \n    def next(self, val):\n        # Get index to write\n        idx = self.index % self.size\n        \n        # Update sum (remove old value if exists)\n        if self.count >= self.size:\n            self.window_sum -= self.buffer[idx]\n        \n        # Add new value\n        self.buffer[idx] = val\n        self.window_sum += val\n        \n        # Update counters\n        self.index += 1\n        self.count = min(self.count + 1, self.size)\n        \n        return self.window_sum / self.count\n\n# Method 3: Using list (less efficient)\nclass MovingAverage3:\n    def __init__(self, size):\n        self.size = size\n        self.values = []\n    \n    def next(self, val):\n        self.values.append(val)\n        \n        # Keep only last size elements\n        if len(self.values) > self.size:\n            self.values.pop(0)  # O(n) - not ideal!\n        \n        return sum(self.values) / len(self.values)\n\n# Method 4: Thread-safe version\nimport threading\n\nclass MovingAverageThreadSafe:\n    def __init__(self, size):\n        self.size = size\n        self.queue = deque()\n        self.window_sum = 0\n        self.lock = threading.Lock()\n    \n    def next(self, val):\n        with self.lock:\n            self.queue.append(val)\n            self.window_sum += val\n            \n            if len(self.queue) > self.size:\n                removed = self.queue.popleft()\n                self.window_sum -= removed\n            \n            return self.window_sum / len(self.queue)\n```\n\n**Circular Buffer Visualization:**\n```\nBuffer size: 4\nInitial: [0, 0, 0, 0]\n         ^\n         index=0\n\nAdd 1: [1, 0, 0, 0], index=1, sum=1\nAdd 2: [1, 2, 0, 0], index=2, sum=3\nAdd 3: [1, 2, 3, 0], index=3, sum=6\nAdd 4: [1, 2, 3, 4], index=0, sum=10\n\nAdd 5 (overwrites 1):\n       [5, 2, 3, 4], index=1\n       sum = 10 - 1 + 5 = 14\n\nAdd 6 (overwrites 2):\n       [5, 6, 3, 4], index=2\n       sum = 14 - 2 + 6 = 18\n```\n\n**Usage Example:**\n```python\nma = MovingAverage1(3)\n\nprint(ma.next(1))   # 1.0 = 1/1\nprint(ma.next(10))  # 5.5 = (1+10)/2\nprint(ma.next(3))   # 4.67 = (1+10+3)/3\nprint(ma.next(5))   # 6.0 = (10+3+5)/3\n\n# Window is now [10, 3, 5]\n```\n\n**Extended: Weighted Moving Average:**\n```python\nclass WeightedMovingAverage:\n    def __init__(self, size):\n        self.size = size\n        self.queue = deque()\n        # Weights: recent values have more weight\n        self.weights = list(range(1, size + 1))\n        self.weight_sum = sum(self.weights)\n    \n    def next(self, val):\n        self.queue.append(val)\n        \n        if len(self.queue) > self.size:\n            self.queue.popleft()\n        \n        # Calculate weighted average\n        weighted_sum = sum(val * weight \n                          for val, weight in \n                          zip(self.queue, self.weights[-len(self.queue):]))\n        \n        active_weight_sum = sum(self.weights[-len(self.queue):])\n        \n        return weighted_sum / active_weight_sum\n\n# Example: [1, 2, 3] with weights [1, 2, 3]\n# Weighted avg = (1*1 + 2*2 + 3*3) / (1+2+3) = 14/6 = 2.33\n```\n\n**Comparison:**\n```\nMethod              Time/call   Space   Thread-safe?\nDeque               O(1)        O(k)    No\nCircular buffer     O(1)        O(k)    No\nList with pop(0)    O(k)        O(k)    No\nWith lock           O(1)        O(k)    Yes\n```\n\n**Edge Cases:**\n```python\n# Empty window\nma = MovingAverage(3)\nprint(ma.next(1))  # 1.0\n\n# Window size 1\nma = MovingAverage(1)\nprint(ma.next(5))  # 5.0\nprint(ma.next(10)) # 10.0 (only keeps last)\n\n# Negative numbers\nma = MovingAverage(2)\nprint(ma.next(-5))  # -5.0\nprint(ma.next(5))   # 0.0\n```\n\n**Real-world Applications:**\n```\n1. Stock price smoothing\n2. Sensor data filtering\n3. Network latency tracking\n4. System metrics monitoring\n5. Audio/video stream processing\n```\n\n**Complexity:**\n- Time: O(1) per call (with deque or circular buffer)\n- Space: O(k) where k is window size\n- O(k) per call if recalculating sum each time\n\n**Key Insight:** Maintain running sum and sliding window to avoid recalculation; deque provides clean API, circular buffer saves memory allocations.",
  "timeComplexity": "O(1) per call",
  "spaceComplexity": "O(k)",
  "videoUrl": "https://www.youtube.com/watch?v=E5SrMJhEEEQ",
  "videoTitle": "Moving Average from Data Stream - Leetcode 346 - Python"
}
