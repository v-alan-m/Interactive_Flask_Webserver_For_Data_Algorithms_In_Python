{
  "id": 29,
  "topic": "Python",
  "level": "Mid Level",
  "question": "Implement a stack that tracks minimum element with O(1) operations",
  "options": [
    "Store min in variable: O(n) when popped",
    "Use two stacks (main + min): O(1) all ops",
    "Recalculate min on each pop: O(n)",
    "Use sorted list: O(log n)"
  ],
  "correct": 1,
  "explanation": "**Optimal Solution: Two Stacks - O(1) all operations**\n\n**Problem:** Stack with push, pop, top, getMin all in O(1)\n```\nOperations:\npush(x)   - add element\npop()     - remove top\ntop()     - get top element\ngetMin()  - get minimum in O(1)\n```\n\n**Concept: Track minimum at each level**\n```\nMain stack: actual values\nMin stack:  minimum value at each level\n\nWhen pushing: store current min\nWhen popping: both stacks pop together\n```\n\n**Visual Example:**\n```\nOperations: push(3), push(5), push(2), push(1), getMin(), pop(), getMin()\n\nAfter push(3):\nmain:   [3]\nminStk: [3]  (3 is min so far)\n\nAfter push(5):\nmain:   [3, 5]\nminStk: [3, 3]  (3 still min)\n\nAfter push(2):\nmain:   [3, 5, 2]\nminStk: [3, 3, 2]  (2 is new min)\n\nAfter push(1):\nmain:   [3, 5, 2, 1]\nminStk: [3, 3, 2, 1]  (1 is new min)\n\ngetMin() → 1 (top of minStk)\n\nAfter pop():\nmain:   [3, 5, 2]\nminStk: [3, 3, 2]\n\ngetMin() → 2 (top of minStk)\n```\n\n**Step-by-Step Trace:**\n```\nOperation    Main Stack    Min Stack    getMin()\npush(3)      [3]           [3]          3\npush(5)      [3,5]         [3,3]        3\npush(2)      [3,5,2]       [3,3,2]      2\npush(1)      [3,5,2,1]     [3,3,2,1]    1\npop()        [3,5,2]       [3,3,2]      2\npop()        [3,5]         [3,3]        3\npop()        [3]           [3]          3\n```\n\n**Python Implementation:**\n```python\n# Method 1: Two stacks (standard approach)\nclass MinStack1:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val):\n        self.stack.append(val)\n        # Push min of (current val, previous min)\n        min_val = min(val, self.min_stack[-1] if self.min_stack else val)\n        self.min_stack.append(min_val)\n    \n    def pop(self):\n        if self.stack:\n            self.stack.pop()\n            self.min_stack.pop()\n    \n    def top(self):\n        return self.stack[-1] if self.stack else None\n    \n    def getMin(self):\n        return self.min_stack[-1] if self.min_stack else None\n\n# Method 2: Store (value, min) tuples (single stack)\nclass MinStack2:\n    def __init__(self):\n        self.stack = []  # [(val, min_at_this_level)]\n    \n    def push(self, val):\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = min(val, self.stack[-1][1])\n            self.stack.append((val, current_min))\n    \n    def pop(self):\n        if self.stack:\n            self.stack.pop()\n    \n    def top(self):\n        return self.stack[-1][0] if self.stack else None\n    \n    def getMin(self):\n        return self.stack[-1][1] if self.stack else None\n\n# Method 3: Only store min when it changes (space optimized)\nclass MinStack3:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val):\n        self.stack.append(val)\n        # Only push if new min or equal to current min\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            # Only pop from min_stack if it was a min\n            if self.min_stack and val == self.min_stack[-1]:\n                self.min_stack.pop()\n    \n    def top(self):\n        return self.stack[-1] if self.stack else None\n    \n    def getMin(self):\n        return self.min_stack[-1] if self.min_stack else None\n```\n\n**Why Two Stacks Work:**\n```\nAt any point, min_stack[-1] contains:\n- The minimum of all elements currently in stack\n\nWhen we pop:\n- Remove top from both stacks\n- Previous minimum is now at top of min_stack\n\nWhen we push:\n- Compare new value with current min\n- Store the smaller one\n```\n\n**Space Optimization Visualization:**\n```\nStandard approach:\npush(5): min_stack = [5]\npush(3): min_stack = [5, 3]\npush(7): min_stack = [5, 3, 3]  ← duplicate\npush(1): min_stack = [5, 3, 3, 1]\n\nOptimized approach (only store when min changes):\npush(5): min_stack = [5]\npush(3): min_stack = [5, 3]\npush(7): min_stack = [5, 3]  ← no duplicate!\npush(1): min_stack = [5, 3, 1]\n```\n\n**Example Usage:**\n```python\nstack = MinStack1()\n\nstack.push(-2)\nstack.push(0)\nstack.push(-3)\n\nprint(stack.getMin())  # -3\nstack.pop()\nprint(stack.top())     # 0\nprint(stack.getMin())  # -2\n```\n\n**Edge Cases:**\n```python\n# Empty stack\nstack = MinStack1()\nstack.getMin()  # None\nstack.top()     # None\n\n# Single element\nstack.push(5)\nstack.getMin()  # 5\nstack.top()     # 5\n\n# All same values\nstack.push(3)\nstack.push(3)\nstack.push(3)\nstack.getMin()  # 3\n\n# Negative numbers\nstack.push(-1)\nstack.push(-2)\nstack.getMin()  # -2\n\n# Min at bottom\nstack.push(1)\nstack.push(2)\nstack.push(3)\nstack.getMin()  # 1 (at bottom)\n```\n\n**Alternative: Single variable (WRONG)**\n```python\n# This DOESN'T work correctly!\nclass WrongMinStack:\n    def __init__(self):\n        self.stack = []\n        self.min = float('inf')\n    \n    def push(self, val):\n        self.stack.append(val)\n        self.min = min(self.min, val)\n    \n    def pop(self):\n        val = self.stack.pop()\n        # PROBLEM: What if we pop the min?\n        # We don't know the previous min!\n        if val == self.min:\n            # Would need O(n) to recalculate\n            self.min = min(self.stack) if self.stack else float('inf')\n```\n\n**Complexity:**\n- push(): O(1) - append to both stacks\n- pop(): O(1) - pop from both stacks\n- top(): O(1) - access top element\n- getMin(): O(1) - access min_stack top\n- Space: O(n) for both stacks\n\n**Key Insight:** Storing minimum at each level ensures O(1) access without recalculation when elements are removed.",
  "timeComplexity": "O(1)",
  "spaceComplexity": "O(n)",
  "videoUrl": "https://www.youtube.com/watch?v=qkLl7nAwDPo",
  "videoTitle": "Min Stack - Leetcode 155 - Python (NeetCode)"
}
