{
  "id": 37,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Implement Dijkstra's shortest path algorithm efficiently",
  "options": [
    "Use BFS: doesn't handle weighted graphs",
    "Use DFS: explores all paths inefficiently",
    "Use min heap (priority queue): O((V+E) log V)",
    "Use adjacency matrix: O(V²)"
  ],
  "correct": 2,
  "explanation": "**Optimal Solution: Min Heap Priority Queue - O((V+E) log V)**\n\n**Problem:** Find shortest path from source to all vertices\n\n**Concept:**\n```\n1. Start at source with distance 0\n2. Visit nearest unvisited vertex\n3. Update distances to neighbors\n4. Repeat until all visited\n```\n\n**Visual Example:**\n```\nGraph:\n    A --1-- B\n    |       |\n    4       2\n    |       |\n    C --1-- D\n\nFrom A:\nStep 1: Visit A (dist=0)\n  Update: B=1, C=4\n  Heap: [(1,B), (4,C)]\n\nStep 2: Visit B (dist=1)\n  Update: D=3 (1+2)\n  Heap: [(3,D), (4,C)]\n\nStep 3: Visit D (dist=3)\n  Update: C=4 (3+1, but 4<4)\n  Heap: [(4,C)]\n\nStep 4: Visit C (dist=4)\n  Done!\n\nShortest paths from A:\nA→A: 0\nA→B: 1\nA→C: 4\nA→D: 3\n```\n\n**Step-by-Step Trace:**\n```\nInitial:\ndistances: {A:0, B:∞, C:∞, D:∞}\nheap: [(0, A)]\n\nIteration 1: Pop A\ndistances: {A:0, B:1, C:4, D:∞}\nheap: [(1,B), (4,C)]\n\nIteration 2: Pop B\ndistances: {A:0, B:1, C:4, D:3}\nheap: [(3,D), (4,C)]\n\nIteration 3: Pop D\ndistances: {A:0, B:1, C:4, D:3}\nheap: [(4,C)]\n\nIteration 4: Pop C\nDone!\n```\n\n**Python Implementation:**\n```python\nimport heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    \"\"\"\n    graph: {node: [(neighbor, weight), ...]}\n    start: starting node\n    returns: {node: shortest_distance}\n    \"\"\"\n    # Initialize distances\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Min heap: (distance, node)\n    heap = [(0, start)]\n    visited = set()\n    \n    while heap:\n        current_dist, current_node = heapq.heappop(heap)\n        \n        # Skip if already visited\n        if current_node in visited:\n            continue\n        \n        visited.add(current_node)\n        \n        # Update neighbors\n        for neighbor, weight in graph[current_node]:\n            distance = current_dist + weight\n            \n            # Only update if we found a shorter path\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    \n    return distances\n\n# With path reconstruction\ndef dijkstra_with_path(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    previous = {node: None for node in graph}\n    \n    heap = [(0, start)]\n    visited = set()\n    \n    while heap:\n        current_dist, current_node = heapq.heappop(heap)\n        \n        if current_node in visited:\n            continue\n        \n        visited.add(current_node)\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_dist + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_node\n                heapq.heappush(heap, (distance, neighbor))\n    \n    return distances, previous\n\ndef reconstruct_path(previous, start, end):\n    \"\"\"Reconstruct path from start to end\"\"\"\n    path = []\n    current = end\n    \n    while current is not None:\n        path.append(current)\n        current = previous[current]\n    \n    path.reverse()\n    \n    if path[0] == start:\n        return path\n    return []  # No path exists\n\n# Usage\ngraph = {\n    'A': [('B', 1), ('C', 4)],\n    'B': [('A', 1), ('D', 2)],\n    'C': [('A', 4), ('D', 1)],\n    'D': [('B', 2), ('C', 1)]\n}\n\ndistances = dijkstra(graph, 'A')\nprint(distances)  # {'A': 0, 'B': 1, 'C': 4, 'D': 3}\n\ndistances, previous = dijkstra_with_path(graph, 'A')\npath = reconstruct_path(previous, 'A', 'D')\nprint(path)  # ['A', 'B', 'D']\n```\n\n**Optimized with early termination:**\n```python\ndef dijkstra_single_target(graph, start, target):\n    \"\"\"Find shortest path to single target (early stop)\"\"\"\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    heap = [(0, start)]\n    visited = set()\n    \n    while heap:\n        current_dist, current_node = heapq.heappop(heap)\n        \n        # Early termination\n        if current_node == target:\n            return current_dist\n        \n        if current_node in visited:\n            continue\n        \n        visited.add(current_node)\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_dist + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    \n    return float('inf')  # No path\n```\n\n**Comparison with other algorithms:**\n```\nAlgorithm       Weights?  Negative?  Time\nBFS             No        -          O(V+E)\nDFS             No        -          O(V+E)\nDijkstra        Yes       No         O((V+E)logV)\nBellman-Ford    Yes       Yes        O(VE)\nFloyd-Warshall  Yes       Yes        O(V³)\n```\n\n**Why Min Heap?**\n```\nWithout heap: O(V²)\n- Check all vertices each iteration\n- V iterations total\n\nWith heap: O((V+E) log V)\n- Pop minimum: O(log V)\n- Update neighbors: O(E) total\n- Each edge processed once\n```\n\n**Common Mistakes:**\n```python\n# WRONG: Not checking if visited\nfor neighbor, weight in graph[current]:\n    heapq.heappush(heap, (distance, neighbor))\n    # Can add duplicates!\n\n# CORRECT: Check before adding\nif neighbor not in visited:\n    heapq.heappush(heap, (distance, neighbor))\n```\n\n**Complexity:**\n- Time: O((V + E) log V) with binary heap\n- Space: O(V) for distances and heap\n- Can optimize to O(V log V + E) with Fibonacci heap\n\n**Key Insight:** Greedy approach works because visiting nearest unvisited node guarantees shortest path to it; min heap efficiently selects next node.",
  "timeComplexity": "O((V+E) log V)",
  "spaceComplexity": "O(V)",
  "videoUrl": "https://www.youtube.com/watch?v=pSqmAO-m7Lk",
  "videoTitle": "Dijkstra's Shortest Path Algorithm - A Detailed and Visual Introduction"
}
