{
  "id": 33,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Design a consistent hashing system for distributed caching",
  "options": [
    "Use modulo N: O(1) but all keys rehash on scaling",
    "Use consistent hashing with virtual nodes: O(log n) lookup",
    "Use range partitioning: uneven distribution",
    "Use random assignment: no consistency"
  ],
  "correct": 1,
  "explanation": "**Optimal Solution: Consistent Hashing with Virtual Nodes - O(log n)**\n\n**Problem:** Distribute keys across servers, minimize rehashing on scale\n\n**Concept:**\n```\n- Map servers and keys to a ring (0 to 2^32-1)\n- Key goes to next server clockwise\n- Add virtual nodes for better distribution\n- Only K/N keys rehash when adding/removing servers\n```\n\n**Visual Ring:**\n```\n        0°\n    S1-v1  |\n           |\nS2-v2 ---- + ---- S1-v2\n    |             |\n    |      Key1   |\nS2-v1      ↓     S3-v1\n        180°\n\nKey1 hash = 45° → goes to S1-v2 (next clockwise)\n```\n\n**Why Virtual Nodes:**\n```\nWithout virtual nodes:\nS1: 0-120°  (33% load)\nS2: 120-240° (33% load)\nS3: 240-360° (33% load)\n\nWith virtual nodes (3 per server):\nMore even distribution across ring\nBetter load balancing\n```\n\n**Python Implementation:**\n```python\nimport hashlib\nimport bisect\n\nclass ConsistentHash:\n    def __init__(self, nodes=None, virtual_nodes=150):\n        self.virtual_nodes = virtual_nodes\n        self.ring = {}  # hash -> node\n        self.sorted_keys = []\n        \n        if nodes:\n            for node in nodes:\n                self.add_node(node)\n    \n    def _hash(self, key):\n        \"\"\"Generate hash for key\"\"\"\n        return int(hashlib.md5(str(key).encode()).hexdigest(), 16)\n    \n    def add_node(self, node):\n        \"\"\"Add node with virtual nodes\"\"\"\n        for i in range(self.virtual_nodes):\n            virtual_key = f\"{node}:{i}\"\n            hash_val = self._hash(virtual_key)\n            self.ring[hash_val] = node\n            bisect.insort(self.sorted_keys, hash_val)\n    \n    def remove_node(self, node):\n        \"\"\"Remove node and its virtual nodes\"\"\"\n        for i in range(self.virtual_nodes):\n            virtual_key = f\"{node}:{i}\"\n            hash_val = self._hash(virtual_key)\n            del self.ring[hash_val]\n            self.sorted_keys.remove(hash_val)\n    \n    def get_node(self, key):\n        \"\"\"Get node responsible for key\"\"\"\n        if not self.ring:\n            return None\n        \n        hash_val = self._hash(key)\n        \n        # Find first node clockwise\n        idx = bisect.bisect_right(self.sorted_keys, hash_val)\n        if idx == len(self.sorted_keys):\n            idx = 0\n        \n        return self.ring[self.sorted_keys[idx]]\n\n# Usage\nch = ConsistentHash(['server1', 'server2', 'server3'])\n\n# Get server for keys\nprint(ch.get_node('user:1001'))  # server2\nprint(ch.get_node('user:1002'))  # server1\n\n# Add server - only ~25% of keys rehash\nch.add_node('server4')\n\n# Remove server\nch.remove_node('server2')\n```\n\n**Key Redistribution Example:**\n```\nBefore adding server4:\nS1: [key1, key4, key7]\nS2: [key2, key5, key8]\nS3: [key3, key6, key9]\n\nAfter adding server4:\nS1: [key1, key7]        (1 key moved)\nS2: [key2, key5]        (1 key moved)\nS3: [key3, key6]        (1 key moved)\nS4: [key4, key8, key9]  (3 keys received)\n\nOnly 3/9 keys rehashed instead of 9/9!\n```\n\n**Comparison:**\n```\nMethod              Rehash on scale    Lookup    Balance\nModulo N            100% (K keys)      O(1)      Perfect\nConsistent Hash     K/N keys           O(log N)  Good\nWith virtual nodes  K/N keys           O(log N)  Excellent\n```\n\n**Complexity:**\n- add_node: O(V log N) where V = virtual nodes\n- get_node: O(log N) binary search\n- Space: O(N * V)\n\n**Key Insight:** Virtual nodes ensure even distribution; only affected keys rehash when scaling.",
  "timeComplexity": "O(log n) lookup",
  "spaceComplexity": "O(N * V)",
  "videoUrl": "https://www.youtube.com/watch?v=zaRkONvyGr8",
  "videoTitle": "Consistent Hashing | Algorithms You Should Know #1 (Back To Back SWE)"
}
