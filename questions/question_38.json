{
  "id": 38,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Serialize and deserialize a binary tree efficiently",
  "options": [
    "Level-order with markers: O(n)",
    "Pre-order with null markers: O(n)",
    "In-order: ambiguous without pre/post",
    "Both A and B work, B is simpler"
  ],
  "correct": 3,
  "explanation": "**Optimal Solutions: Pre-order or Level-order - O(n)**\n\n**Problem:** Convert tree to string and back\n\n**Why In-order Fails:**\n```\nTree 1:     Tree 2:\n   1           2\n  /           /\n 2           1\n\nBoth give in-order: [2, 1]\nAmbiguous! Cannot reconstruct uniquely.\n```\n\n**Pre-order Serialization:**\n```\nTree:\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\nPre-order with null markers:\n\"1,2,null,null,3,4,null,null,5,null,null\"\n\nRead left-to-right:\n1: root\n2: left child of 1\nnull: no left child of 2\nnull: no right child of 2\n3: right child of 1\n4: left child of 3\n...\n```\n\n**Visual Process:**\n```\nSerialize (Pre-order DFS):\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\nVisit order: 1 → 2 → null → null → 3 → 4 → null → null → 5 → null → null\nResult: \"1,2,N,N,3,4,N,N,5,N,N\"\n\nDeserialize:\n\"1,2,N,N,3,4,N,N,5,N,N\"\n ↓\nBuild: 1\n      / \\\n     2   3\n        / \\\n       4   5\n```\n\n**Python Implementation:**\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Method 1: Pre-order DFS\nclass Codec1:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        result = []\n        \n        def dfs(node):\n            if not node:\n                result.append('null')\n                return\n            \n            result.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        \n        dfs(root)\n        return ','.join(result)\n    \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n        values = iter(data.split(','))\n        \n        def build():\n            val = next(values)\n            if val == 'null':\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = build()\n            node.right = build()\n            return node\n        \n        return build()\n\n# Method 2: Level-order BFS\nfrom collections import deque\n\nclass Codec2:\n    def serialize(self, root):\n        if not root:\n            return ''\n        \n        result = []\n        queue = deque([root])\n        \n        while queue:\n            node = queue.popleft()\n            \n            if node:\n                result.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append('null')\n        \n        return ','.join(result)\n    \n    def deserialize(self, data):\n        if not data:\n            return None\n        \n        values = data.split(',')\n        root = TreeNode(int(values[0]))\n        queue = deque([root])\n        i = 1\n        \n        while queue and i < len(values):\n            node = queue.popleft()\n            \n            # Left child\n            if values[i] != 'null':\n                node.left = TreeNode(int(values[i]))\n                queue.append(node.left)\n            i += 1\n            \n            # Right child\n            if i < len(values) and values[i] != 'null':\n                node.right = TreeNode(int(values[i]))\n                queue.append(node.right)\n            i += 1\n        \n        return root\n\n# Method 3: More compact (using indices)\nclass Codec3:\n    def serialize(self, root):\n        def dfs(node):\n            if not node:\n                return '#'\n            return str(node.val) + ',' + dfs(node.left) + ',' + dfs(node.right)\n        \n        return dfs(root)\n    \n    def deserialize(self, data):\n        def build(values):\n            val = next(values)\n            if val == '#':\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = build(values)\n            node.right = build(values)\n            return node\n        \n        return build(iter(data.split(',')))\n```\n\n**Example Usage:**\n```python\ncodec = Codec1()\n\n# Build tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.right.left = TreeNode(4)\nroot.right.right = TreeNode(5)\n\n# Serialize\nserialized = codec.serialize(root)\nprint(serialized)\n# \"1,2,null,null,3,4,null,null,5,null,null\"\n\n# Deserialize\nnew_root = codec.deserialize(serialized)\n\n# Verify\nprint(codec.serialize(new_root))\n# \"1,2,null,null,3,4,null,null,5,null,null\"\n```\n\n**Comparison:**\n```\nMethod        Traversal   Space (string)   Easy to read?\nPre-order     DFS         Compact          Medium\nLevel-order   BFS         More nulls       Easy\nPost-order    DFS         Compact          Hard\nIn-order      -           N/A              Ambiguous!\n```\n\n**Step-by-Step Deserialize:**\n```\nData: \"1,2,null,null,3,4,null,null,5,null,null\"\nIterator: ^\n\nStep 1: Read \"1\" → Create root(1)\nStep 2: Read \"2\" → Create root.left(2)\nStep 3: Read \"null\" → root.left.left = None\nStep 4: Read \"null\" → root.left.right = None\nStep 5: Read \"3\" → Create root.right(3)\nStep 6: Read \"4\" → Create root.right.left(4)\nStep 7: Read \"null\" → root.right.left.left = None\nStep 8: Read \"null\" → root.right.left.right = None\nStep 9: Read \"5\" → Create root.right.right(5)\nStep 10: Read \"null\" → root.right.right.left = None\nStep 11: Read \"null\" → root.right.right.right = None\n\nDone!\n```\n\n**Edge Cases:**\n```python\n# Empty tree\ncodec.serialize(None)  # \"null\"\ncodec.deserialize(\"null\")  # None\n\n# Single node\nroot = TreeNode(1)\ncodec.serialize(root)  # \"1,null,null\"\n\n# Left-skewed tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.left.left = TreeNode(3)\ncodec.serialize(root)  # \"1,2,3,null,null,null,null\"\n```\n\n**Complexity:**\n- Serialize: O(n) - visit each node once\n- Deserialize: O(n) - create each node once\n- Space: O(n) for serialized string + O(h) recursion stack\n\n**Key Insight:** Pre-order traversal with null markers provides unambiguous reconstruction; use iterator pattern for elegant deserialization.",
  "timeComplexity": "O(n)",
  "spaceComplexity": "O(n)",
  "videoUrl": "https://www.youtube.com/watch?v=u4JAi2JJhI8",
  "videoTitle": "Serialize and Deserialize Binary Tree - Leetcode 297 - Python (NeetCode)"
}
