{
  "id": 28,
  "topic": "Python",
  "level": "Mid Level",
  "question": "Find K most common words in a text efficiently",
  "options": [
    "Sort by frequency: O(n log n)",
    "Use Counter.most_common(k): O(n + k log n)",
    "Use heap with k elements: O(n log k)",
    "Both B and C are optimal"
  ],
  "correct": 3,
  "explanation": "**Optimal Solutions: Counter.most_common() or Heap - O(n + k log n)**\n\n**Problem:** Find k most frequent words in text\n```\nText: \"the quick brown fox jumps over the lazy dog the\"\nk = 2\n\nWord counts:\n\"the\": 3\n\"quick\": 1\n\"brown\": 1\n...\n\nResult: [\"the\", \"quick\"] (or any word with count 1)\n```\n\n**Visual Process:**\n```\nText → Split → Count → Top K\n\n\"the quick brown fox...\" \n    ↓\n[\"the\", \"quick\", \"brown\", ...]\n    ↓\n{\"the\": 3, \"quick\": 1, \"brown\": 1, ...}\n    ↓\n[(\"the\", 3), (\"quick\", 1)]  (top 2)\n```\n\n**Approach 1: Counter.most_common(k)**\n```\nStep 1: Split text into words\nStep 2: Count frequencies with Counter\nStep 3: Get top k with most_common(k)\n\nUses heap internally for efficiency\n```\n\n**Python Implementation:**\n```python\nfrom collections import Counter\nimport heapq\nimport re\n\n# Method 1: Counter.most_common (simplest)\ndef topKWords1(text, k):\n    words = text.lower().split()\n    counter = Counter(words)\n    return [word for word, count in counter.most_common(k)]\n\n# Method 2: Counter with regex (handles punctuation)\ndef topKWords2(text, k):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    counter = Counter(words)\n    return [word for word, count in counter.most_common(k)]\n\n# Method 3: Manual heap (more control)\ndef topKWords3(text, k):\n    words = text.lower().split()\n    freq = {}\n    for word in words:\n        freq[word] = freq.get(word, 0) + 1\n    \n    # Use heap to get top k\n    return heapq.nlargest(k, freq.keys(), key=freq.get)\n\n# Method 4: Min heap of size k (memory efficient)\ndef topKWords4(text, k):\n    words = text.lower().split()\n    freq = {}\n    for word in words:\n        freq[word] = freq.get(word, 0) + 1\n    \n    # Maintain heap of size k\n    heap = []\n    for word, count in freq.items():\n        heapq.heappush(heap, (count, word))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return [word for count, word in sorted(heap, reverse=True)]\n\n# Method 5: With stopword filtering\ndef topKWords5(text, k, stopwords=None):\n    if stopwords is None:\n        stopwords = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at'}\n    \n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    words = [w for w in words if w not in stopwords]\n    counter = Counter(words)\n    return [word for word, count in counter.most_common(k)]\n```\n\n**Example Execution:**\n```python\ntext = \"the quick brown fox jumps over the lazy dog the quick\"\nk = 3\n\nStep 1: Split\nwords = [\"the\", \"quick\", \"brown\", \"fox\", \"jumps\", \n         \"over\", \"the\", \"lazy\", \"dog\", \"the\", \"quick\"]\n\nStep 2: Count\nCounter({\n    'the': 3,\n    'quick': 2,\n    'brown': 1,\n    'fox': 1,\n    'jumps': 1,\n    'over': 1,\n    'lazy': 1,\n    'dog': 1\n})\n\nStep 3: most_common(3)\n[('the', 3), ('quick', 2), ('brown', 1)]\n\nResult: ['the', 'quick', 'brown']\n```\n\n**Handling Ties:**\n```python\ntext = \"apple banana apple cherry banana\"\nk = 2\n\nCounts: {'apple': 2, 'banana': 2, 'cherry': 1}\n\n# Counter.most_common preserves insertion order for ties\ncounter.most_common(2)\n# [('apple', 2), ('banana', 2)]\n\n# To break ties alphabetically:\ndef topKWordsAlpha(text, k):\n    words = text.lower().split()\n    counter = Counter(words)\n    # Sort by (-count, word) for count desc, alpha asc\n    sorted_words = sorted(counter.items(), \n                         key=lambda x: (-x[1], x[0]))\n    return [word for word, count in sorted_words[:k]]\n```\n\n**Advanced: Return with counts**\n```python\ndef topKWordsWithCounts(text, k):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    counter = Counter(words)\n    return counter.most_common(k)\n\n# Example\ntopKWordsWithCounts(\"the cat the dog\", 2)\n# [('the', 2), ('cat', 1)]\n```\n\n**Performance Comparison:**\n```\nMethod                  Time            Space   Notes\nCounter.most_common()   O(n + k log n)  O(n)    Built-in, fast\nheapq.nlargest()        O(n + k log n)  O(n)    Similar\nMin heap (size k)       O(n log k)      O(n)    Best for large n, small k\nSort all                O(n log n)      O(n)    Not optimal\n```\n\n**Real-world Example:**\n```python\ntext = \"\"\"\nTo be or not to be, that is the question.\nWhether 'tis nobler in the mind to suffer\nThe slings and arrows of outrageous fortune.\n\"\"\"\n\n# Top 3 words\ntopKWords2(text, 3)\n# ['to', 'the', 'be']\n\n# Top 3 excluding stopwords\nstopwords = {'to', 'be', 'or', 'not', 'that', 'is', 'the', \n             'whether', 'tis', 'in'}\ntopKWords5(text, 3, stopwords)\n# ['nobler', 'mind', 'suffer']\n```\n\n**Edge Cases:**\n```python\n# Empty text\ntopKWords(\"\", 5)  # []\n\n# k larger than unique words\ntopKWords(\"hi hi bye\", 10)  # ['hi', 'bye']\n\n# All words same frequency\ntopKWords(\"a b c\", 2)  # ['a', 'b'] (or any 2)\n\n# Case sensitivity\ntopKWords2(\"The the THE\", 1)  # ['the'] (3 occurrences)\n\n# Punctuation\ntopKWords2(\"hello, world! hello.\", 1)  # ['hello']\n```\n\n**Complexity:**\n- Time: O(n) to count + O(k log n) for heap selection\n- Space: O(n) for frequency map\n- Counter.most_common internally uses heapq.nlargest\n\n**Key Insight:** Counter.most_common(k) is Pythonic and efficient; for very large texts with small k, min-heap of size k is optimal.",
  "timeComplexity": "O(n + k log n)",
  "spaceComplexity": "O(n)",
  "videoUrl": "https://www.youtube.com/watch?v=cupg2TGIkyM",
  "videoTitle": "Top K Frequent Words - Leetcode 692 - Python (NeetCode)"
}
