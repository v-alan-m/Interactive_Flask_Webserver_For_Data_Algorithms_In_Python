{
  "id": 35,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Design an autocomplete system with frequency ranking",
  "options": [
    "Sort all matches: O(n log n) per query",
    "Use Trie + heap for top K: O(m + k log k)",
    "Use prefix tree with sorted lists: O(m + k)",
    "Linear search: O(n) per query"
  ],
  "correct": 1,
  "explanation": "**Optimal Solution: Trie + Min Heap - O(m + k log k)**\n\n**Problem:** Suggest top K completions based on frequency\n\n**Design:**\n```\n1. Trie stores all words\n2. Each node tracks words passing through it\n3. Search prefix, collect candidates\n4. Use heap to get top K by frequency\n```\n\n**Visual Trie with Frequencies:**\n```\n           root\n          /    \\\n        c(5)   d(3)\n        /        \\\n      a(5)       o(3)\n      /  \\         \\\n    t(3) r(2)      g(3)\n    |     |         |\n   *3    *2        *3\n   \n\"cat\": 3 times\n\"car\": 2 times  \n\"dog\": 3 times\n\nSearch \"ca\": returns [\"cat\":3, \"car\":2]\n```\n\n**Python Implementation:**\n```python\nimport heapq\nfrom collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n        self.frequency = 0\n        self.word = None\n\nclass AutocompleteSystem:\n    def __init__(self, sentences, times):\n        self.root = TrieNode()\n        self.current_node = self.root\n        self.current_search = \"\"\n        \n        # Build trie with frequencies\n        for sentence, freq in zip(sentences, times):\n            self._insert(sentence, freq)\n    \n    def _insert(self, word, frequency):\n        \"\"\"Insert word with frequency into trie\"\"\"\n        node = self.root\n        \n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        \n        node.is_end = True\n        node.word = word\n        node.frequency += frequency\n    \n    def _search_prefix(self, prefix):\n        \"\"\"Find all words with given prefix\"\"\"\n        node = self.root\n        \n        # Navigate to prefix end\n        for char in prefix:\n            if char not in node.children:\n                return []\n            node = node.children[char]\n        \n        # Collect all words from this point\n        results = []\n        self._collect_words(node, results)\n        return results\n    \n    def _collect_words(self, node, results):\n        \"\"\"DFS to collect all complete words\"\"\"\n        if node.is_end:\n            results.append((node.word, node.frequency))\n        \n        for child in node.children.values():\n            self._collect_words(child, results)\n    \n    def input(self, char):\n        \"\"\"Process input character\"\"\"\n        if char == '#':\n            # Save current search\n            self._insert(self.current_search, 1)\n            self.current_search = \"\"\n            self.current_node = self.root\n            return []\n        \n        self.current_search += char\n        \n        # Get all matches\n        matches = self._search_prefix(self.current_search)\n        \n        # Return top 3 by frequency (then lexicographically)\n        matches.sort(key=lambda x: (-x[1], x[0]))\n        return [word for word, freq in matches[:3]]\n\n# Optimized version with heap\nclass AutocompleteSystemOptimized:\n    def __init__(self, sentences, times):\n        self.root = TrieNode()\n        self.current_search = \"\"\n        \n        for sentence, freq in zip(sentences, times):\n            self._insert(sentence, freq)\n    \n    def _insert(self, word, frequency):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n        node.word = word\n        node.frequency += frequency\n    \n    def _get_top_k(self, candidates, k=3):\n        \"\"\"Use heap to get top k efficiently\"\"\"\n        if len(candidates) <= k:\n            candidates.sort(key=lambda x: (-x[1], x[0]))\n            return [word for word, freq in candidates]\n        \n        # Use max heap (negate frequency)\n        heap = []\n        for word, freq in candidates:\n            heapq.heappush(heap, (-freq, word))\n        \n        result = []\n        for _ in range(min(k, len(heap))):\n            freq, word = heapq.heappop(heap)\n            result.append(word)\n        \n        return result\n    \n    def input(self, char):\n        if char == '#':\n            self._insert(self.current_search, 1)\n            self.current_search = \"\"\n            return []\n        \n        self.current_search += char\n        \n        # Navigate trie\n        node = self.root\n        for c in self.current_search:\n            if c not in node.children:\n                return []\n            node = node.children[c]\n        \n        # Collect candidates\n        candidates = []\n        self._collect_words(node, candidates)\n        \n        # Return top 3\n        return self._get_top_k(candidates, 3)\n    \n    def _collect_words(self, node, results):\n        if node.is_end:\n            results.append((node.word, node.frequency))\n        for child in node.children.values():\n            self._collect_words(child, results)\n```\n\n**Usage Example:**\n```python\nsentences = [\"i love you\", \"island\", \"iroman\", \"i love leetcode\"]\ntimes = [5, 3, 2, 2]\n\nsystem = AutocompleteSystem(sentences, times)\n\n# User types 'i'\nprint(system.input('i'))  \n# [\"i love you\", \"island\", \"i love leetcode\"]\n# (sorted by frequency: 5, 3, 2)\n\n# User types ' ' (space)\nprint(system.input(' '))\n# [\"i love you\", \"i love leetcode\"]\n\n# User types 'a'\nprint(system.input('a'))\n# [] (no matches for \"i a\")\n\n# User finishes with '#'\nprint(system.input('#'))\n# [] (saves \"i a\" with frequency 1)\n```\n\n**Complexity Analysis:**\n```\nOperation       Time            Space\nInsert          O(m)            O(m) where m = word length\nSearch          O(m + n log k)  O(n) where n = matching words\nCollect words   O(n)            O(n)\nHeap top K      O(k log k)      O(k)\n```\n\n**Optimization Ideas:**\n```\n1. Cache results at each node\n2. Store only top K at each node\n3. Use inverted index for common prefixes\n4. Implement lazy evaluation\n```\n\n**Key Insight:** Trie enables fast prefix search; heap efficiently extracts top K; frequency stored at leaf nodes.",
  "timeComplexity": "O(m + k log k)",
  "spaceComplexity": "O(total chars)",
  "videoUrl": "https://www.youtube.com/watch?v=D4T2N0yAr20",
  "videoTitle": "Design Search Autocomplete System - Leetcode 642 - Python"
}
