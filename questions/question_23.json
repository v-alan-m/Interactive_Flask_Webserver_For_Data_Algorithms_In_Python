{
  "id": 23,
  "topic": "Python",
  "level": "Mid Level",
  "question": "Implement LRU Cache using OrderedDict in Python",
  "options": [
    "Regular dict + manual ordering: O(n) for move",
    "OrderedDict with move_to_end(): O(1)",
    "List + dict: O(n) for reordering",
    "Doubly linked list + dict: O(1) but complex"
  ],
  "correct": 1,
  "explanation": "**Optimal Solution: OrderedDict.move_to_end() - O(1)**\n\n**Concept:** LRU (Least Recently Used) Cache\n```\n- Fixed capacity\n- get(key): return value, mark as recently used\n- put(key, val): insert/update, evict LRU if full\n\nOrder: [MRU] ... [LRU]\n```\n\n**Example Operations:**\n```\nCapacity = 2\n\nput(1, 'a'):  [1]\nput(2, 'b'):  [2, 1]\nget(1):       [1, 2]  (1 moved to front)\nput(3, 'c'):  [3, 1]  (2 evicted as LRU)\nget(2):       None    (2 not found)\nget(1):       'a'     [1, 3]\nput(4, 'd'):  [4, 1]  (3 evicted as LRU)\n```\n\n**Visual State Changes:**\n```\nOperation       State           Action\nput(1, 'a')     {1:'a'}         Add 1\nput(2, 'b')     {1:'a', 2:'b'}  Add 2\nget(1)          {2:'b', 1:'a'}  Move 1 to end\nput(3, 'c')     {1:'a', 3:'c'}  Evict 2 (LRU)\n                 ↑MRU    ↑LRU\n```\n\n**Why OrderedDict is Perfect:**\n```\nPython 3.7+: OrderedDict maintains insertion order\nmove_to_end(key): O(1) - moves key to end\npopitem(last=False): O(1) - removes first (LRU)\n\nPerfect for LRU cache!\n```\n\n**Python Implementation:**\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        \n        # Move to end (mark as recently used)\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        # If key exists, remove it first\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        \n        self.cache[key] = value\n        \n        # Evict LRU if over capacity\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\n# Alternative: More explicit with comments\nclass LRUCache2:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        \n        # Update access order: remove and re-insert\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n    \n    def put(self, key, value):\n        # Remove if exists (will re-insert at end)\n        if key in self.cache:\n            self.cache.pop(key)\n        \n        self.cache[key] = value\n        \n        # Remove oldest (first item)\n        if len(self.cache) > self.capacity:\n            oldest = next(iter(self.cache))\n            del self.cache[oldest]\n```\n\n**Usage Example:**\n```python\ncache = LRUCache(2)\n\ncache.put(1, 1)\n# cache: {1: 1}\n\ncache.put(2, 2)\n# cache: {1: 1, 2: 2}\n\ncache.get(1)\n# returns 1, cache: {2: 2, 1: 1}\n\ncache.put(3, 3)\n# evicts key 2, cache: {1: 1, 3: 3}\n\ncache.get(2)\n# returns -1 (not found)\n\ncache.put(4, 4)\n# evicts key 1, cache: {3: 3, 4: 4}\n\ncache.get(1)\n# returns -1 (not found)\n\ncache.get(3)\n# returns 3, cache: {4: 4, 3: 3}\n\ncache.get(4)\n# returns 4, cache: {3: 3, 4: 4}\n```\n\n**OrderedDict Methods:**\n```python\nod = OrderedDict()\n\n# Add items\nod['a'] = 1\nod['b'] = 2\n\n# Move to end (most recent)\nod.move_to_end('a')  # O(1)\n\n# Remove first (least recent)\nod.popitem(last=False)  # O(1)\n\n# Remove last (most recent)\nod.popitem(last=True)   # O(1)\n\n# Get first key\nnext(iter(od))\n```\n\n**Comparison with Manual Implementation:**\n```\nApproach            Code Lines   Complexity   Maintenance\nOrderedDict         ~15 lines    O(1)         Easy\nDict + DLL          ~60 lines    O(1)         Hard\nDict + List         ~20 lines    O(n)         Medium\n```\n\n**Before Python 3.7:**\n```python\nfrom collections import OrderedDict\n\n# OrderedDict always maintains order\n# Regular dict only guaranteed order in 3.7+\n\ncache = OrderedDict()  # Use this for LRU\ncache = {}  # Don't use for LRU in Python < 3.7\n```\n\n**Complexity:**\n- get(): O(1) - hash lookup + move_to_end\n- put(): O(1) - hash insert + possible eviction\n- Space: O(capacity)\n\n**Key Insight:** OrderedDict.move_to_end() makes LRU cache trivial to implement with O(1) operations.",
  "timeComplexity": "O(1)",
  "spaceComplexity": "O(capacity)",
  "videoUrl": "https://www.youtube.com/watch?v=7ABFKPK2hD4",
  "videoTitle": "LRU Cache - Leetcode 146 - Python (NeetCode)"
}
