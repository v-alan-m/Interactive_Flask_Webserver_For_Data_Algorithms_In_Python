{
  "id": 27,
  "topic": "Python",
  "level": "Mid Level",
  "question": "Merge two dictionaries efficiently in Python 3.9+",
  "options": [
    "Use loop: O(n) but verbose",
    "Use update(): O(n) modifies original",
    "Use {**d1, **d2}: O(n) creates new dict",
    "Use d1 | d2: O(n) most Pythonic (3.9+)"
  ],
  "correct": 3,
  "explanation": "**Optimal Solution: Union Operator | (Python 3.9+) - O(n)**\n\n**Problem:** Merge two dictionaries, handling key conflicts\n```\nd1 = {'a': 1, 'b': 2}\nd2 = {'b': 3, 'c': 4}\n\nResult: {'a': 1, 'b': 3, 'c': 4}\n        (d2 values override d1 for 'b')\n```\n\n**Visual Merge Process:**\n```\nd1:     {'a': 1, 'b': 2}\nd2:     {'b': 3, 'c': 4}\n         ↓       ↓    ↓\n         keep   override  add\n         ↓       ↓    ↓\nResult: {'a': 1, 'b': 3, 'c': 4}\n```\n\n**Key Conflict Resolution:**\n```\nWhen same key exists in both:\n- Last value wins (right-most dict)\n- d1 | d2 → d2['key'] overrides d1['key']\n\nExample:\n{'x': 10} | {'x': 20} = {'x': 20}\n            ↑ wins\n```\n\n**Python Implementation:**\n```python\n# Method 1: Union operator | (Python 3.9+, best)\ndef merge1(d1, d2):\n    return d1 | d2\n\n# Method 2: Unpacking ** (Python 3.5+)\ndef merge2(d1, d2):\n    return {**d1, **d2}\n\n# Method 3: dict.update() (modifies original)\ndef merge3(d1, d2):\n    result = d1.copy()\n    result.update(d2)\n    return result\n\n# Method 4: Union update |= (in-place, Python 3.9+)\ndef merge4(d1, d2):\n    d1 |= d2  # Modifies d1 in place\n    return d1\n\n# Method 5: ChainMap (doesn't merge, creates view)\nfrom collections import ChainMap\ndef merge5(d1, d2):\n    return dict(ChainMap(d2, d1))  # Note order!\n\n# Method 6: Manual loop (most control)\ndef merge6(d1, d2):\n    result = {}\n    for key, value in d1.items():\n        result[key] = value\n    for key, value in d2.items():\n        result[key] = value\n    return result\n```\n\n**Multiple Dictionary Merge:**\n```python\nd1 = {'a': 1}\nd2 = {'b': 2}\nd3 = {'c': 3}\nd4 = {'a': 10}  # Override 'a'\n\n# Method 1: Multiple unions\nresult = d1 | d2 | d3 | d4\n# {'a': 10, 'b': 2, 'c': 3}\n\n# Method 2: Multiple unpacking\nresult = {**d1, **d2, **d3, **d4}\n# {'a': 10, 'b': 2, 'c': 3}\n\n# Method 3: Using reduce\nfrom functools import reduce\nresult = reduce(lambda x, y: x | y, [d1, d2, d3, d4])\n```\n\n**Conflict Examples:**\n```python\nd1 = {'a': 1, 'b': 2, 'c': 3}\nd2 = {'b': 20, 'c': 30, 'd': 4}\n\nresult = d1 | d2\n# {'a': 1, 'b': 20, 'c': 30, 'd': 4}\n#          ↑ from d2  ↑ from d2\n\n# Order matters!\nresult = d2 | d1\n# {'b': 2, 'c': 3, 'd': 4, 'a': 1}\n#   ↑ from d1  ↑ from d1\n```\n\n**Advanced: Custom Merge Logic:**\n```python\n# Sum values for duplicate keys\ndef merge_sum(d1, d2):\n    result = d1.copy()\n    for key, value in d2.items():\n        result[key] = result.get(key, 0) + value\n    return result\n\nmerge_sum({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n# {'a': 1, 'b': 5, 'c': 4}\n\n# Keep both values in list\ndef merge_list(d1, d2):\n    from collections import defaultdict\n    result = defaultdict(list)\n    for d in [d1, d2]:\n        for key, value in d.items():\n            result[key].append(value)\n    return dict(result)\n\nmerge_list({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n# {'a': [1], 'b': [2, 3], 'c': [4]}\n\n# Deep merge (nested dicts)\ndef deep_merge(d1, d2):\n    result = d1.copy()\n    for key, value in d2.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        else:\n            result[key] = value\n    return result\n\nd1 = {'a': {'x': 1, 'y': 2}}\nd2 = {'a': {'y': 3, 'z': 4}}\ndeep_merge(d1, d2)\n# {'a': {'x': 1, 'y': 3, 'z': 4}}\n```\n\n**Comparison Table:**\n```\nMethod              Python  In-place  Readable  Speed\nd1 | d2             3.9+    No        ✓✓✓       Fast\n{**d1, **d2}        3.5+    No        ✓✓        Fast\nd1.update(d2)       All     Yes       ✓✓        Fast\nd1 |= d2            3.9+    Yes       ✓✓✓       Fast\ndict(d1, **d2)      All     No        ✓         Fast\nChainMap            All     No        ✓         Slow\nManual loop         All     No        ✓         Medium\n```\n\n**Edge Cases:**\n```python\n# Empty dicts\n{} | {'a': 1}  # {'a': 1}\n{'a': 1} | {}  # {'a': 1}\n{} | {}        # {}\n\n# Same keys, different values\n{'a': 1} | {'a': 2}  # {'a': 2}\n\n# None values\n{'a': None} | {'a': 1}  # {'a': 1}\n{'a': 1} | {'a': None}  # {'a': None}\n\n# Nested dicts (shallow merge)\n{'a': {'x': 1}} | {'a': {'y': 2}}\n# {'a': {'y': 2}}  - replaces entire nested dict!\n```\n\n**Performance Notes:**\n```\nAll methods are O(n) where n = total keys\n\n| operator is:\n- Slightly faster than **\n- More readable\n- Type-safe (both must be dicts)\n```\n\n**Complexity:**\n- Time: O(n + m) where n, m = sizes of d1, d2\n- Space: O(n + m) for new dict\n- All operations visit each key once\n\n**Key Insight:** Use | operator in Python 3.9+ for cleanest syntax; unpacking ** for older versions.",
  "timeComplexity": "O(n + m)",
  "spaceComplexity": "O(n + m)",
  "videoUrl": "https://www.youtube.com/watch?v=u7aA-ynform",
  "videoTitle": "Python Dictionary Merge - New Union Operators (Real Python)"
}
