{
  "id": 36,
  "topic": "Python",
  "level": "Senior Level",
  "question": "Implement a sliding window rate limiter for API requests",
  "options": [
    "Fixed window: can allow 2x limit at boundary",
    "Sliding window log: O(n) space per user",
    "Sliding window counter: O(1) space, accurate",
    "Token bucket: different use case"
  ],
  "correct": 2,
  "explanation": "**Optimal Solution: Sliding Window Counter - O(1) space**\n\n**Problem:** Limit requests to K per time window, handle boundary cases\n\n**Fixed Window Problem:**\n```\nLimit: 10 requests/minute\nWindow 1: 00:00-01:00\nWindow 2: 01:00-02:00\n\n00:59 → 10 requests ✓\n01:00 → 10 requests ✓\n\nTotal in 1 second: 20 requests! (2x limit)\n```\n\n**Sliding Window Solution:**\n```\nCurrent time: 01:30\nWindow: 00:30-01:30 (last 60 seconds)\n\nCount requests in this sliding window\nNo boundary issues!\n```\n\n**Visual:**\n```\nFixed Windows:\n|----Window1----|----Window2----|\n00:00         01:00           02:00\n  10 reqs         10 reqs\n               ↑ Both allowed at boundary!\n\nSliding Window:\n      |----60sec window----|\n00:30                    01:30\n    Exact count over 60 seconds\n```\n\n**Python Implementation:**\n```python\nimport time\nfrom collections import deque, defaultdict\n\nclass SlidingWindowRateLimiter:\n    def __init__(self, max_requests, window_seconds):\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        # user_id -> deque of timestamps\n        self.requests = defaultdict(deque)\n    \n    def allow_request(self, user_id):\n        \"\"\"Check if request should be allowed\"\"\"\n        current_time = time.time()\n        user_requests = self.requests[user_id]\n        \n        # Remove old requests outside window\n        cutoff_time = current_time - self.window_seconds\n        while user_requests and user_requests[0] < cutoff_time:\n            user_requests.popleft()\n        \n        # Check if under limit\n        if len(user_requests) < self.max_requests:\n            user_requests.append(current_time)\n            return True\n        \n        return False\n    \n    def get_wait_time(self, user_id):\n        \"\"\"Get seconds to wait before next request\"\"\"\n        current_time = time.time()\n        user_requests = self.requests[user_id]\n        \n        if len(user_requests) < self.max_requests:\n            return 0\n        \n        # Wait until oldest request expires\n        oldest = user_requests[0]\n        wait_time = (oldest + self.window_seconds) - current_time\n        return max(0, wait_time)\n\n# Optimized: Sliding Window Counter (O(1) space)\nclass SlidingWindowCounterOptimized:\n    def __init__(self, max_requests, window_seconds):\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        # user_id -> (prev_window_count, prev_window_time, \n        #             curr_window_count, curr_window_time)\n        self.windows = defaultdict(lambda: [0, 0, 0, 0])\n    \n    def allow_request(self, user_id):\n        current_time = time.time()\n        window_id = int(current_time // self.window_seconds)\n        \n        data = self.windows[user_id]\n        prev_count, prev_window, curr_count, curr_window = data\n        \n        # New window started\n        if window_id > curr_window:\n            prev_count = curr_count\n            prev_window = curr_window\n            curr_count = 0\n            curr_window = window_id\n        \n        # Calculate weighted count\n        elapsed_in_window = current_time - (window_id * self.window_seconds)\n        prev_weight = 1 - (elapsed_in_window / self.window_seconds)\n        weighted_count = (prev_count * prev_weight) + curr_count\n        \n        if weighted_count < self.max_requests:\n            curr_count += 1\n            self.windows[user_id] = [prev_count, prev_window, \n                                     curr_count, curr_window]\n            return True\n        \n        return False\n\n# Token Bucket (different algorithm)\nclass TokenBucketRateLimiter:\n    def __init__(self, capacity, refill_rate):\n        self.capacity = capacity\n        self.refill_rate = refill_rate  # tokens per second\n        # user_id -> (tokens, last_refill_time)\n        self.buckets = defaultdict(lambda: [capacity, time.time()])\n    \n    def allow_request(self, user_id):\n        current_time = time.time()\n        tokens, last_time = self.buckets[user_id]\n        \n        # Refill tokens\n        elapsed = current_time - last_time\n        tokens = min(self.capacity, \n                    tokens + (elapsed * self.refill_rate))\n        \n        if tokens >= 1:\n            tokens -= 1\n            self.buckets[user_id] = [tokens, current_time]\n            return True\n        \n        self.buckets[user_id] = [tokens, current_time]\n        return False\n```\n\n**Usage Example:**\n```python\n# Allow 10 requests per 60 seconds\nlimiter = SlidingWindowRateLimiter(10, 60)\n\nfor i in range(15):\n    user_id = \"user123\"\n    allowed = limiter.allow_request(user_id)\n    \n    if allowed:\n        print(f\"Request {i+1}: Allowed\")\n    else:\n        wait = limiter.get_wait_time(user_id)\n        print(f\"Request {i+1}: Denied. Wait {wait:.1f}s\")\n    \n    time.sleep(0.1)  # Small delay\n```\n\n**Comparison:**\n```\nAlgorithm           Space/user  Accuracy    Burst?\nFixed Window        O(1)        Poor        Yes\nSliding Log         O(n)        Perfect     No\nSliding Counter     O(1)        ~99%        No\nToken Bucket        O(1)        Good        Yes (limited)\nLeaky Bucket        O(1)        Good        No\n```\n\n**Redis Implementation:**\n```python\nimport redis\nimport time\n\nclass RedisRateLimiter:\n    def __init__(self, redis_client, max_requests, window_seconds):\n        self.redis = redis_client\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n    \n    def allow_request(self, user_id):\n        key = f\"rate_limit:{user_id}\"\n        current_time = time.time()\n        \n        # Remove old entries\n        self.redis.zremrangebyscore(key, 0, \n                                   current_time - self.window_seconds)\n        \n        # Count current requests\n        count = self.redis.zcard(key)\n        \n        if count < self.max_requests:\n            # Add new request\n            self.redis.zadd(key, {str(current_time): current_time})\n            self.redis.expire(key, self.window_seconds)\n            return True\n        \n        return False\n```\n\n**Complexity:**\n- Sliding Log: O(n) space, O(n) time per request\n- Sliding Counter: O(1) space, O(1) time\n- Token Bucket: O(1) space, O(1) time\n\n**Key Insight:** Sliding window counter balances accuracy with memory efficiency; weighted calculation prevents boundary exploitation.",
  "timeComplexity": "O(1) or O(n) depending on impl",
  "spaceComplexity": "O(1) or O(n) depending on impl",
  "videoUrl": "https://www.youtube.com/watch?v=mhUQe4BKZXs",
  "videoTitle": "Rate Limiting Algorithms Explained (System Design Interview)"
}
